---
title: "Writing Macros"
kind: chapter
---

  
  
    <div id="clojure08.html">
      
	<div class="chapter-number">Chapter 8</div>
	<h1>Writing Macros</h1>
	<p class="x1st-Para"><span>When I was 18, I got a job as a night auditor at a hotel in Santa Fe, New Mexico, working four nights a week from 11 </span><span class="Keycap">pm</span><span> till 7 </span><span class="Keycap">am</span><span>. After a few months of this sleepless schedule, my emotions took on a life of their own. One night, at about </span></p>
	<p class="BodyFirst">3 <span class="Keycap">am</span>, I was watching an infomercial for a product claiming to restore men’s hair. As I watched the story of a formerly bald individual, I became overwhelmed with sincere joy. “At last!” my brain gushed. “This man has gotten the love and success he deserves! What an incredible product, giving hope to the hopeless!”</p>
	<p class="Body">Since then I’ve found myself wondering if I could somehow re-create the emotional abandon and appreciation for life induced by chronic sleep deprivation. Some kind of potion, perhaps—a couple quaffs to unleash my inner Richard Simmons, but not for too long.</p>
        <img src="/assets/images/cftbat/writing-macros/simmons-potion.png" class="right" />
	<p class="Body">Just as a potion would allow me to temporarily alter my fundamental nature, macros allow you to modify Clojure in ways that just aren’t possible with other languages. With macros, you can extend Clojure to suit your problem space, building up the language.</p>
	<p class="Body">In this chapter, you’ll thoroughly examine how to write macros, starting with basic examples and moving up in complexity. You’ll close by donning your make-believe cap and using macros to validate customer orders in your imaginary online potion store.</p>
	<p class="Body">By the end of the chapter, you’ll understand all the tools you’ll use to write macros: quote, syntax quote, unquote, unquote splicing (aka the piñata tool), and gensym. You’ll also learn about the dangers lying in wait <span>for unsuspecting macro authors: </span><span>double</span> evaluation, variable capture, and macro infection.</p>
	<h2>Macros Are Essential</h2>
	<p class="BodyFirst">Before you start writing macros, I want to help you put them in the proper <span>context. Yes, macros are cooler than a polar bear’s toenails, but you shouldn’t think of macros as some esoteric tool you pull out when you feel like getting </span>extra fancy with your code. In fact, macros allow Clojure to derive a lot of its built-in functionality from a tiny core of functions and special forms. Take <code>when</code>, for example. <code>when</code> has this general form:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">when </span><span class="tok-nv">boolean-expression</span>
  <span class="tok-nv">expression-1</span>
  <span class="tok-nv">expression-2</span>
  <span class="tok-nv">expression-3</span>
  <span class="tok-nv">...</span>
  <span class="tok-nv">expression-x</span><span class="tok-p">)</span>
</code></pre></div></div>

	<p class="Body">You might think that <code>when</code> is a special form like <code>if</code>. Well guess what? It’s not! In most other languages, you can only create conditional expressions using special keywords, and there’s no way to create your own conditional operators. However, <code>when</code> is actually a macro. </p>
	<p class="Body">In this macro expansion, you can see that <code>when</code> is implemented in terms of <code>if</code> and <code>do</code>:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">macroexpand </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">when </span><span class="tok-nv">boolean-expression</span>
                <span class="tok-nv">expression-1</span>
                <span class="tok-nv">expression-2</span>
                <span class="tok-nv">expression-3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (if boolean-expression</span>
       <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-nv">expression-1</span>
           <span class="tok-nv">expression-2</span>
           <span class="tok-nv">expression-3</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">This shows that macros are an integral part of Clojure development—<span>they’re even used to provide fundamental operations. Macros aren’t reserved for exotic special cases; you should think of macro writing as just another tool </span>in your tool satchel. As you learn to write your own macros, you’ll see how they allow you to extend the language even further so that it fits the shape of your particular problem domain.</p>
	<h2>Anatomy of a Macro</h2>
	<p class="BodyFirst">Macro definitions look much like function definitions. They have a name, an optional document string, an argument list, and a body. The body will almost always return a list. This makes sense because macros are a way of transforming a data structure into a form Clojure can evaluate, and Clojure uses lists to represent function calls, special form calls, and macro calls. You can use any function, macro, or special form within the macro body, and you call macros just like you would a function or special form.</p>
	<p class="Body">As an example, here’s our old friend the <code>infix</code> macro:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">infix</span>
  <span class="tok-s">"Use this macro when you pine for the notation of your childhood"</span>
  <span class="tok-p">[</span><span class="tok-nv">infixed</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-p">(</span><span class="tok-nb">second </span><span class="tok-nv">infixed</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-nv">infixed</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">last </span><span class="tok-nv">infixed</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">This macro rearranges a list into the correct order for infix notation. Here’s an example:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">infix</span> <span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; 2</span>
</code></pre></div></div>

	<p class="Body">One key difference between functions and macros is that function <span>arguments are fully evaluated before they’re passed to the function, </span>whereas macros receive arguments as unevaluated data. You can see this in the example. If you tried evaluating <code>(1 + 1)</code> on its own, you would get an exception. However, because you’re making a macro call, the unevalu<span>ated list </span><code>(1 + 1)</code><span> is passed to </span><code>infix</code><span>. Then the macro can use </span><code>first</code><span>, </span><code>second</code><span>, and </span><code>last</code><span> to rearrange the list so Clojure can evaluate it:</span></p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">macroexpand </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nf">infix</span> <span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">)))</span>
<span class="tok-c1">; =&gt; (+ 1 1)</span>
</code></pre></div></div>

	<p class="Body">By expanding the macro, you can see that <code>infix</code> rearranges <code>(1 + 1)</code> into <code>(+ 1 1)</code>. Handy!</p>
	<p class="Body">You can also use argument destructuring in macro definitions, just like you can with functions:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">infix-2</span>
  <span class="tok-p">[[</span><span class="tok-nv">operand1</span> <span class="tok-nv">op</span> <span class="tok-nv">operand2</span><span class="tok-p">]]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-nv">op</span> <span class="tok-nv">operand1</span> <span class="tok-nv">operand2</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">Destructuring arguments lets you succinctly bind values to symbols based on their position in a sequential argument. Here, <code>infix-2</code> takes a sequential data structure as an argument and destructures by position so the first value is named <code>operand1</code>, the second value is named <code>op</code>, and the third value is named <code>operand2</code> within the macro.</p>
	<p class="Body"><span>You can also create multiple-arity macros, and in fact the fundamen</span><span>tal Boolean operations </span><code>and</code><span> and </span><code>or</code><span> are defined as macros. Here’s </span><code>and</code><span>’s source code:</span></p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">and</span>
  <span class="tok-s">"Evaluates exprs one at a time, from left to right. If a form</span>
<span class="tok-s">  returns logical false (nil or false), and returns that value and</span>
<span class="tok-s">  doesn't evaluate any of the other expressions, otherwise it returns</span>
<span class="tok-s">  the value of the last expr. (and) returns true."</span>
  <span class="tok-p">{</span><span class="tok-ss">:added</span> <span class="tok-s">"1.0"</span><span class="tok-p">}</span>
  <span class="tok-p">([]</span> <span class="tok-nv">true</span><span class="tok-p">)</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-nv">x</span><span class="tok-p">)</span>
  <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-o">&amp;</span> <span class="tok-nv">next</span><span class="tok-p">]</span>
   <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">and#</span> <span class="tok-o">~</span><span class="tok-nv">x</span><span class="tok-p">]</span>
      <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">and#</span> <span class="tok-p">(</span><span class="tok-nb">and </span><span class="tok-o">~@</span><span class="tok-nv">next</span><span class="tok-p">)</span> <span class="tok-nv">and#</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="Body">There’s a lot of stuff going on in this example, including the symbols <code>`</code> and <code>~@</code>, which you’ll learn about soon. What’s important to realize for now is that there are three macro bodies here: a 0-arity macro body that always returns <code>true</code>, a 1-arity macro body that returns the operand, and an <em>n</em>-arity macro body that recursively calls itself. That’s right: macros can be recursive, and they also can use rest args (<code>&amp; next</code> in the <em>n</em>-arity macro body), just like functions.</p>
	<p class="Body">Now that you’re comfortable with the anatomy of macros, it’s time to strap yourself to your thinking mast Odysseus-style and learn to write macro bodies.</p>
	<h2>Building Lists for Evaluation</h2>
	<p class="BodyFirst"><span>Macro writing is all about building a list for Clojure to evaluate, and it </span>requires a kind of inversion to your normal way of thinking. For one, you’ll often need to quote expressions to get unevaluated data structures in your final list (we’ll get back to that in a moment). More generally, you’ll need to be extra careful about the difference between a <em>symbol</em> and its <em>value</em>. </p>
	<h3>Distinguishing Symbols and Values</h3>
	<p class="BodyFirst"><span>Say you want to create a macro that takes an expression and both prints and </span><span>returns its value. (This differs from </span><code>println</code><span> in that </span><code>println</code><span> always returns </span><code>nil</code>.) You want your macro to return lists that look like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-nv">expression</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">result</span><span class="tok-p">)</span>
  <span class="tok-nv">result</span><span class="tok-p">)</span>
</code></pre></div></div>

	<p class="Body">Your first version of the macro might look like this, using the <code>list</code> function to create the list that Clojure should evaluate:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"> <span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">my-print-whoopsie</span>
  <span class="tok-p">[</span><span class="tok-nv">expression</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result</span> <span class="tok-nv">expression</span><span class="tok-p">]</span>
        <span class="tok-p">(</span><span class="tok-nb">list println </span><span class="tok-nv">result</span><span class="tok-p">)</span>
        <span class="tok-nv">result</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">However, if you tried this, you’d get the exception <code>Can't take the value of a macro: #'clojure.core/let</code>. What’s going on here?</p>
	<p class="Body">The reason this happens is that your macro body tries to get the <em>value</em> that the <em>symbol</em> <code>let</code> refers to, whereas what you actually want to do is return <span>the </span><code>let</code><span> symbol itself. There are other problems, too: you’re trying to get the </span><span>value of </span><code>result</code><span>, which is unbound, and you’re trying to get the value of </span><code>println</code><span> instead of returning its symbol. Here’s how you would write the </span>macro to do what you want:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">my-print</span>
  <span class="tok-p">[</span><span class="tok-nv">expression</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'let</span> <span class="tok-p">[</span><span class="tok-ss">'result</span> <span class="tok-nv">expression</span><span class="tok-p">]</span>
        <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'println</span> <span class="tok-ss">'result</span><span class="tok-p">)</span>
        <span class="tok-ss">'result</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">Here, you’re quoting each symbol you want to use as a symbol by prefixing it with the single quote character, <code>'</code>. This tells Clojure to <em>turn off</em> evaluation for whatever follows, in this case preventing Clojure from trying to resolve the symbols and instead just returning the symbols. The ability to use quoting to turn off evaluation is central to writing macros, so let’s give the topic its own section.</p>
	<h3>Simple Quoting</h3>
	<p class="BodyFirst">You’ll almost always use quoting within your macros to obtain an unevaluated symbol. Let’s go through a brief refresher on quoting and then see how you might use it in a macro.</p>
	<p class="Body">First, here’s a simple function call with no quoting:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; 3</span>
</code></pre></div></div>

	<p class="Body">If we add <code>quote</code> at the beginning, it returns an unevaluated data structure:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (+ 1 2) </span>
</code></pre></div></div>

	<p class="Body">Here in the returned list, <code>+</code> is a symbol. If we evaluate this plus symbol, it yields the plus function:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">+</span>
<span class="tok-c1">; =&gt; #&lt;core$_PLUS_ clojure.core$_PLUS_@47b36583&gt;</span>
</code></pre></div></div>

	<p class="Body">Whereas if we quote the plus symbol, it just yields the plus symbol:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-nv">+</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; +</span>
</code></pre></div></div>

	<p class="Body">Evaluating an unbound symbol raises an exception:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">sweating-to-the-oldies</span>
<span class="tok-c1">; =&gt; Unable to resolve symbol: sweating-to-the-oldies in this context</span>
</code></pre></div></div>

	<p class="Body">But quoting the symbol returns a symbol regardless of whether the symbol has a value associated with it:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-nv">sweating-to-the-oldies</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; sweating-to-the-oldies</span>
</code></pre></div></div>

	<p class="Body">The single quote character is a reader macro for <code>(quote </code><span class="LiteralItal">x</span><code>)</code>:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; (+ 1 2)</span>

<span class="tok-ss">'dr-jekyll-and-richard-simmons</span>
<span class="tok-c1">; =&gt; dr-jekyll-and-richard-simmons</span>
</code></pre></div></div>

	<p class="Body">You can see quoting at work in the <code>when</code> macro. This is <code>when</code><span class="Default-Paragraph-Font">’</span>s actual source code:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">when</span>
  <span class="tok-s">"Evaluates test. If logical true, evaluates body in an implicit do."</span>
  <span class="tok-p">{</span><span class="tok-ss">:added</span> <span class="tok-s">"1.0"</span><span class="tok-p">}</span>
  <span class="tok-p">[</span><span class="tok-nb">test </span><span class="tok-o">&amp;</span> <span class="tok-nv">body</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'if</span> <span class="tok-nb">test </span><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-ss">'do</span> <span class="tok-nv">body</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">Notice that the macro definition quotes both <code>if</code> and <code>do</code>. That’s because you want these symbols to be in the final list that <code>when</code> returns for evaluation. Here’s an example of what that returned list might look like:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">macroexpand </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">when </span><span class="tok-p">(</span><span class="tok-nf">the-cows-come</span> <span class="tok-ss">:home</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">call</span> <span class="tok-nv">me</span> <span class="tok-ss">:pappy</span><span class="tok-p">)</span>
                <span class="tok-p">(</span><span class="tok-nf">slap</span> <span class="tok-nv">me</span> <span class="tok-ss">:silly</span><span class="tok-p">)))</span>
<span class="tok-c1">; =&gt; (if (the-cows-come :home)</span>
       <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">call</span> <span class="tok-nv">me</span> <span class="tok-ss">:pappy</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">slap</span> <span class="tok-nv">me</span> <span class="tok-ss">:silly</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">Here’s another example of source code for a built-in macro, this time for <code>unless</code>:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">unless</span>
  <span class="tok-s">"Inverted 'if'"</span>
  <span class="tok-p">[</span><span class="tok-nb">test </span><span class="tok-o">&amp;</span> <span class="tok-nv">branches</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">conj </span><span class="tok-p">(</span><span class="tok-nb">reverse </span><span class="tok-nv">branches</span><span class="tok-p">)</span> <span class="tok-nb">test </span><span class="tok-ss">'if</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">Again, you have to quote <code>if</code> because you want the unevaluated symbol to be placed in the resulting list, like this one:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">macroexpand </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nf">unless</span> <span class="tok-p">(</span><span class="tok-nf">done-been</span> <span class="tok-nv">slapped?</span> <span class="tok-nv">me</span><span class="tok-p">)</span>
                      <span class="tok-p">(</span><span class="tok-nf">slap</span> <span class="tok-nv">me</span> <span class="tok-ss">:silly</span><span class="tok-p">)</span>
                      <span class="tok-p">(</span><span class="tok-nf">say</span> <span class="tok-s">"I reckon that'll learn me"</span><span class="tok-p">)))</span>
<span class="tok-c1">; =&gt; (if (done-been slapped? me)</span>
       <span class="tok-p">(</span><span class="tok-nf">say</span> <span class="tok-s">"I reckon that'll learn me"</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">slap</span> <span class="tok-nv">me</span> <span class="tok-ss">:silly</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">In many cases, you’ll use simple quoting like this when writing macros, but most often you’ll use the more powerful syntax quote.</p>
	<h3>Syntax Quoting</h3>
	<p class="BodyFirst"><span>So far, you’ve seen macros that build up lists by using the </span><code>list</code><span> function to create a list along with </span><code>'</code><span> (quote), and functions that operate on lists </span>like <code>first</code>, <code>second</code>, <code>last</code>, and so on. Indeed, you could write macros that way <span>until the cows come home. Sometimes, though, it leads to tedious and </span>verbose code. </p>
	<p class="Body">Syntax quoting returns unevaluated data structures, similar to normal quoting. However, there are two important differences. One difference is that syntax quoting will return the <em>fully qualified</em> symbols (that is, with the symbol’s namespace included). Let’s compare quoting and syntax quoting.</p>
	<p class="Body">Quoting does not include a namespace if your code doesn’t include a namespace:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-ss">'+</span>
<span class="tok-c1">; =&gt; +</span>
</code></pre></div></div>

	<p class="Body">Write out the namespace, and it’ll be returned by normal quote:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-ss">'clojure.core/+</span>
<span class="tok-c1">; =&gt; clojure.core/+</span>
</code></pre></div></div>

	<p class="Body">Syntax quoting will always include the symbol’s full namespace:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-nv">+</span>
<span class="tok-c1">; =&gt; clojure.core/+</span>
</code></pre></div></div>

	<p class="Body">Quoting a list recursively quotes all the elements:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; (+ 1 2)</span>
</code></pre></div></div>

	<p class="Body">Syntax quoting a list recursively syntax quotes all the elements:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; (clojure.core/+ 1 2)</span>
</code></pre></div></div>

	<p class="Body">The reason syntax quotes include the namespace is to help you avoid name collisions, a topic covered in Chapter 6.</p>
	<p class="Body">The other difference between quoting and syntax quoting is that the latter allows you to <em>unquote</em> forms using the tilde, <code>~</code>. It’s kind of like kryptonite in that way: whenever Superman is around kryptonite, his powers disappear. Whenever a tilde appears within a syntax-quoted form, the syntax quote’s power to return unevaluated, fully namespaced forms disappears. Here’s an example:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (clojure.core/+ 1 2)</span>
</code></pre></div></div>

	<p class="Body">Because it comes after the tilde, <code>(inc 1) </code>is evaluated instead of being quoted. Without the unquote, syntax quoting returns the unevaluated form with fully qualified symbols:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (clojure.core/+ 1 (clojure.core/inc 1))</span>
</code></pre></div></div>

	<p class="Body">If you’re familiar with string interpolation, you can think of syntax quoting/unquoting similarly. In both cases, you’re creating a kind of template, placing a few variables within a larger, static structure. For example, in Ruby you can create the string <code>"Churn your butter, Jebediah"</code> through concatenation:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nb">name = </span><span class="tok-s">"Jebediah"</span>
<span class="tok-s">"Churn your butter, "</span> <span class="tok-nb">+ name + </span><span class="tok-s">"!"</span>
</code></pre></div></div>

	<p class="BodyFirst">or through interpolation:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-s">"Churn your butter, #{name}!"</span>
</code></pre></div></div>

	<p class="Body">In the same way that string interpolation leads to clearer and more concise code, syntax quoting and unquoting allow you to create lists more clearly and concisely. Compare using the <code>list</code> function, shown first, with using syntax quoting:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'+</span> <span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (+ 1 2)</span>

<span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (clojure.core/+ 1 2)</span>
</code></pre></div></div>

	<p class="Body">As you can see, the syntax-quote version is more concise. Also, its visual form is closer to the final form of the list, making it easier to understand.</p>
	<h2>Using Syntax Quoting in a Macro</h2>
	<p class="BodyFirst">Now that you have a good handle on how syntax quoting works, take a look at the <code>code-critic</code> macro. You’re going to write a more concise version using syntax quoting.</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">code-critic</span>
  <span class="tok-s">"Phrases are courtesy Hermes Conrad from Futurama"</span>
  <span class="tok-p">[</span><span class="tok-nv">bad</span> <span class="tok-nv">good</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'do</span>
        <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'println</span>
              <span class="tok-s">"Great squid of Madrid, this is bad code:"</span>
              <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'quote</span> <span class="tok-nv">bad</span><span class="tok-p">))</span>
        <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'println</span>
              <span class="tok-s">"Sweet gorilla of Manila, this is good code:"</span>
              <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'quote</span> <span class="tok-nv">good</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">code-critic</span> <span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; Great squid of Madrid, this is bad code: (1 + 1)</span>
<span class="tok-c1">; =&gt; Sweet gorilla of Manila, this is good code: (+ 1 1)</span>
</code></pre></div></div>

	<p class="Body">Just looking at all those tedious repetitions of <code>list</code> and single quotes makes me cringe. But if you rewrite <code>code-critic</code> using syntax quoting, you can make it sleek and concise:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">code-critic</span>
  <span class="tok-s">"Phrases are courtesy Hermes Conrad from Futurama"</span>
  <span class="tok-p">[</span><span class="tok-nv">bad</span> <span class="tok-nv">good</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Great squid of Madrid, this is bad code:"</span>
                <span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">bad</span><span class="tok-p">))</span>
       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Sweet gorilla of Manila, this is good code:"</span>
                <span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">good</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="Body"><span>In this case, you want to quote everything except for the symbols </span><code>good</code> and <code>bad</code>. In the original version, you have to quote each piece individ­ually and explicitly place it in a list in an unwieldy fashion, just to prevent those two symbols from being quoted. With syntax quoting, you can just wrap the entire <code>do</code> expression in a quote and simply unquote the two sym<span>bols that you want to evaluate.</span></p>
	<p class="Body">And thus concludes the introduction to the mechanics of writing a macro! Sweet sacred boa of Western and Eastern Samoa, that was a lot!</p>
	<p class="Body">To sum up, macros receive unevaluated, arbitrary data structures as arguments and return data structures that Clojure evaluates. When defining your macro, you can use argument destructuring just like you can with functions and <code>let</code> bindings. You can also write multiple-arity and recursive macros.</p>
	<p class="Body"><span>Most of the time, your macros will return lists. You can build up the list </span>to be returned by using <code>list</code> functions or by using syntax quoting. Syntax <span>quoting usually leads to code that’s clearer and more concise because it lets you create a template of the data structure you want to return that’s easier to parse visually. Whether you use syntax quoting or plain quoting, it’s impor</span>tant to be clear about the distinction between a symbol and the value it evaluates to when building up your list. And if you want your macro to return <span>multiple forms for Clojure to evaluate, make sure to wrap them in a </span><code>do</code><span>.</span></p>
	<h2>Refactoring a Macro and Unquote Splicing</h2>
	<p class="BodyFirst">That <code>code-critic</code> macro in the preceding section could still use some improvement. Look at the duplication! The two <code>println</code> calls are nearly identical. Let’s clean that up. First, let’s create a function to generate those <code>println</code> lists. Functions are easier to think about and play with than macros, so it’s often a good idea to move macro guts to helper functions:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">criticize-code</span>
  <span class="tok-p">[</span><span class="tok-nv">criticism</span> <span class="tok-nv">code</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-o">~</span><span class="tok-nv">criticism</span> <span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">code</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">code-critic</span>
  <span class="tok-p">[</span><span class="tok-nv">bad</span> <span class="tok-nv">good</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nf">criticize-code</span> <span class="tok-s">"Cursed bacteria of Liberia, this is bad code:"</span> <span class="tok-nv">bad</span><span class="tok-p">)</span>
       <span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nf">criticize-code</span> <span class="tok-s">"Sweet sacred boa of Western and Eastern Samoa, this is good code:"</span> <span class="tok-nv">good</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">Notice how the <code>criticize-code</code> function returns a syntax-quoted list. This is how you build up the list that the macro will return.</p>
	<p class="Body">There’s more room for improvement, though. The code still has multiple, nearly identical calls to a function. In a situation like this where you want to apply the same function to a collection of values, it makes sense to use a seq function like <code>map</code>:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">code-critic</span>
  <span class="tok-p">[</span><span class="tok-nv">bad</span> <span class="tok-nv">good</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">apply </span><span class="tok-nv">criticize-code</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
             <span class="tok-p">[[</span><span class="tok-s">"Great squid of Madrid, this is bad code:"</span> <span class="tok-nv">bad</span><span class="tok-p">]</span>
              <span class="tok-p">[</span><span class="tok-s">"Sweet gorilla of Manila, this is good code:"</span> <span class="tok-nv">good</span><span class="tok-p">]])))</span>
</code></pre></div></div>

	<p class="Body">This is looking a little better. You’re mapping over each criticism/code pair and applying the <code>criticize-code </code>function to the pair. Let’s try to run the code:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">code-critic</span> <span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; NullPointerException</span>
</code></pre></div></div>

	<p class="Body">Oh no! That didn’t work at all! What happened? The problem is that <code>map</code> returns a list, and in this case, it returned a list of <code>println</code> expressions. We just want the result of each <code>println</code> call, but instead, this code sticks both results in a list and then tries to evaluate that list.</p>
	<p class="Body">In other words, as it’s evaluating this code, Clojure gets to something like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">do</span>
 <span class="tok-p">((</span><span class="tok-nf">clojure.core/println</span> <span class="tok-s">"criticism"</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nf">clojure.core/println</span> <span class="tok-s">"criticism"</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="BodyFirst">then evaluates the first <code>println</code> call to give us this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">do</span>
 <span class="tok-p">(</span><span class="tok-nf">nil</span>
  <span class="tok-p">(</span><span class="tok-nf">clojure.core/println</span> <span class="tok-s">"criticism"</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="BodyFirst">and after evaluating the second <code>println</code> call, does this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">do</span>
 <span class="tok-p">(</span><span class="tok-nf">nil</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body"><span>This is the cause of the exception. </span><code>println</code><span> evaluates to </span><code>nil</code><span>, so we end up with something like </span><code>(nil nil)</code><span>. </span><code>nil</code><span> isn’t callable, and we get a </span><code>NullPointerException</code><span>.</span></p>
	<p class="Body"><span>What an inconvenience! But as it happens, unquote splicing was invented </span><span>precisely to handle this kind of situation. Unquote splicing is performed </span>with <code>~@</code>. If you merely unquote a list, this is what you get:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-o">~</span><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (clojure.core/+ (1 2 3))</span>
</code></pre></div></div>

	<p class="Body">However, if you use unquote splicing, this is what you get:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-o">~@</span><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (clojure.core/+ 1 2 3)</span>
</code></pre></div></div>

	<p class="Body">Unquote splicing unwraps a seqable data structure, placing its contents directly within the enclosing syntax-quoted data structure. It’s like the <code>~@</code> is a sledgehammer and whatever follows it is a piñata, and the result is the most terrifying and awesome party you’ve ever been to.</p>
	<p class="Body">Anyway, if you use unquote splicing in your code critic, then everything will work great:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">code-critic</span>
  <span class="tok-p">[{</span><span class="tok-ss">:keys</span> <span class="tok-p">[</span><span class="tok-nv">good</span> <span class="tok-nv">bad</span><span class="tok-p">]}]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-o">~@</span><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">apply </span><span class="tok-nv">criticize-code</span> <span class="tok-nv">%</span><span class="tok-p">)</span>
              <span class="tok-p">[[</span><span class="tok-s">"Sweet lion of Zion, this is bad code:"</span> <span class="tok-nv">bad</span><span class="tok-p">]</span>
               <span class="tok-p">[</span><span class="tok-s">"Great cow of Moscow, this is good code:"</span> <span class="tok-nv">good</span><span class="tok-p">]])))</span>

<span class="tok-p">(</span><span class="tok-nf">code-critic</span> <span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-nb">+ </span><span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; Sweet lion of Zion, this is bad code: (1 + 1)</span>
<span class="tok-c1">; =&gt; Great cow of Moscow, this is good code: (+ 1 1)</span>
</code></pre></div></div>

	<p class="Body">Woohoo! You’ve successfully extracted repetitive code into a function and made your macro code cleaner. Sweet guinea pig of Winnipeg, that is good code!</p>
	<h2>Things to Watch Out For</h2>
	<p class="BodyFirst">Macros have a couple of sneaky gotchas that you should be aware of. In this section, you’ll learn about some macro pitfalls and how to avoid them. I hope you haven’t unstrapped yourself from your thinking mast.</p>
	<h3>Variable Capture</h3>
	<p class="BodyFirst"><em>Variable capture</em> occurs when a macro introduces a binding that, unknown to the macro’s user, eclipses an existing binding. For example, in the following code, a macro mischievously introduces its own <code>let</code> binding, and that messes with the code:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">message</span> <span class="tok-s">"Good job!"</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">with-mischief</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">stuff-to-do</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">concat </span><span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-ss">'let</span> <span class="tok-p">[</span><span class="tok-ss">'message</span> <span class="tok-s">"Oh, big deal!"</span><span class="tok-p">])</span>
          <span class="tok-nv">stuff-to-do</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">with-mischief</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Here's how I feel about that thing you did: "</span> <span class="tok-nv">message</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; Here's how I feel about that thing you did: Oh, big deal!</span>
</code></pre></div></div>

	<p class="Body">The <code>println</code> call references the symbol <code>message</code>, which we think is bound to the string <code>"Good job!"</code>. However, the <code>with-mischief</code> macro has created a new binding for <code>message</code>.</p>
	<p class="Body">Notice that this macro didn’t use syntax quoting. Doing so would result in an exception:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">message</span> <span class="tok-s">"Good job!"</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">with-mischief</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">stuff-to-do</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">message</span> <span class="tok-s">"Oh, big deal!"</span><span class="tok-p">]</span>
     <span class="tok-o">~@</span><span class="tok-nv">stuff-to-do</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">with-mischief</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Here's how I feel about that thing you did: "</span> <span class="tok-nv">message</span><span class="tok-p">))</span>
<span class="tok-c1">; Exception: Can't let qualified name: user/message</span>
</code></pre></div></div>

	<p class="Body">This exception is for your own good: syntax quoting is designed to prevent you from accidentally capturing variables within macros. If you want to introduce <code>let</code> bindings in your macro, you can use a <em>gensym</em>. The <code>gensym</code> function produces unique symbols on each successive call:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">gensym</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; G__655</span>

<span class="tok-p">(</span><span class="tok-nf">gensym</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; G__658</span>
</code></pre></div></div>

	<p class="Body">You can also pass a symbol prefix:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">gensym </span><span class="tok-ss">'message</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; message4760</span>

<span class="tok-p">(</span><span class="tok-nb">gensym </span><span class="tok-ss">'message</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; message4763</span>
</code></pre></div></div>

	<p class="Body">Here’s how you could rewrite <code>with-mischief</code> to be less mischievous:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">without-mischief</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">stuff-to-do</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">macro-message</span> <span class="tok-p">(</span><span class="tok-nb">gensym </span><span class="tok-ss">'message</span><span class="tok-p">)]</span>
    <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-o">~</span><span class="tok-nv">macro-message</span> <span class="tok-s">"Oh, big deal!"</span><span class="tok-p">]</span>
       <span class="tok-o">~@</span><span class="tok-nv">stuff-to-do</span>
       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"I still need to say: "</span> <span class="tok-o">~</span><span class="tok-nv">macro-message</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">without-mischief</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Here's how I feel about that thing you did: "</span> <span class="tok-nv">message</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; Here's how I feel about that thing you did:  Good job!</span>
<span class="tok-c1">; =&gt; I still need to say:  Oh, big deal! </span>
</code></pre></div></div>

	<p class="Body"><span>This example avoids variable capture by using </span><code>gensym</code><span> to create a new, unique symbol that then gets bound to </span><code>macro-message</code><span>. Within the syntax-quoted</span><code> let</code><span> expression, </span><code>macro-message</code><span> is unquoted, resolving to the </span>gensym’d symbol. This gensym’d symbol is distinct from any symbols within <code>stuff-to-do</code><span>, so you avoid variable capture. </span><span>Because this is such a common pattern, you can use an</span><em> auto-gensym</em><span>. Auto-gensyms are more concise and </span>convenient ways to use gensyms:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nf">blarg#</span> <span class="tok-nv">blarg#</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">blarg__2869__auto__</span> <span class="tok-nv">blarg__2869__auto__</span><span class="tok-p">)</span>

<span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">name#</span> <span class="tok-s">"Larry Potter"</span><span class="tok-p">]</span> <span class="tok-nv">name#</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; (clojure.core/let [name__2872__auto__ "Larry Potter"] name__2872__auto__)</span>
</code></pre></div></div>

	<p class="Body"><span>In this example, you create an auto-gensym by appending a hash mark (or </span><em>hashtag</em><span>, if you must insist) to a symbol within a syntax-quoted list. Clojure automatically ensures that each instance of </span><span class="LiteralItal">x</span><code>#</code><span> resolves to the same symbol within the same syntax-quoted list, that each instance of </span><span class="LiteralItal">y</span><code>#</code><span> resolves similarly, and so on.</span></p>
	<p class="Body"><code>gensym</code><span> and auto-gensym are both used all the time when writing macros, </span>and they allow you to avoid variable capture.</p>
	<h3>Double Evaluation</h3>
	<p class="BodyFirst">Another gotcha to watch out for when writing macros is <em>double evaluation</em>, which occurs when a form passed to a macro as an argument gets evaluated more than once. Consider the following:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">report</span>
  <span class="tok-p">[</span><span class="tok-nv">to-try</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-o">~</span><span class="tok-nv">to-try</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)</span> <span class="tok-s">"was successful:"</span> <span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)</span> <span class="tok-s">"was not successful:"</span> <span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)))</span>
     
<span class="tok-c1">;; Thread/sleep takes a number of milliseconds to sleep for</span>
<span class="tok-p">(</span><span class="tok-nf">report</span> <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">This code is meant to test its argument for truthiness. If the argument is truthy, it’s considered successful; if it’s falsey, it’s unsuccessful. The macro prints whether or not its argument was successful. In this case, you would actually sleep for two seconds because <code>(Thread/sleep 1000)</code> gets evaluated twice: once right after <code>if</code> and again when <code>println</code> gets called. This happens because the code <code>(do (Thread/sleep 1000) (+ 1 1))</code> is repeated throughout the macro expansion. It’s as if you’d written this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
           <span class="tok-s">"was successful:"</span>
           <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)))</span>
  
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
           <span class="tok-s">"was not successful:"</span>
           <span class="tok-p">(</span><span class="tok-k">do </span><span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">1000</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="Body">“Big deal!” your inner example critic says. Well, if your code did something like transfer money between bank accounts, this would be a very big deal. Here’s how you could avoid this problem:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">report</span>
  <span class="tok-p">[</span><span class="tok-nv">to-try</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">result#</span> <span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">result#</span>
       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)</span> <span class="tok-s">"was successful:"</span> <span class="tok-nv">result#</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">(</span><span class="tok-k">quote </span><span class="tok-o">~</span><span class="tok-nv">to-try</span><span class="tok-p">)</span> <span class="tok-s">"was not successful:"</span> <span class="tok-nv">result#</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="Body">By placing <code>to-try</code> in a <code>let</code> expression, you only evaluate that code once and bind the result to an auto-gensym’d symbol, <code>result#</code>, which you can now reference without reevaluating the <code>to-try</code> code.</p>
	<h3>Macros All the Way Down</h3>
	<p class="BodyFirst">One subtle pitfall of using macros is that you can end up having to write more and more of them to get anything done. This is a consequence of the fact that macro expansion happens before evaluation.</p>
	<p class="Body"><span>For example, let’s say you wanted to </span><code>doseq</code><span> using the </span><code>report</code><span> macro. Instead </span>of multiple calls to report:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">report</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (= 1 1) was successful: true</span>

<span class="tok-p">(</span><span class="tok-nf">report</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (= 1 2) was not successful: false</span>
</code></pre></div></div>

	<p class="BodyFirst">let’s iterate:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">doseq </span><span class="tok-p">[</span><span class="tok-nv">code</span> <span class="tok-p">[</span><span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)]]</span>
  <span class="tok-p">(</span><span class="tok-nf">report</span> <span class="tok-nv">code</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; code was successful: (= 1 1)</span>
<span class="tok-c1">; =&gt; code was successful: (= 1 2)</span>
</code></pre></div></div>

	<p class="Body">The report macro works fine when we pass it functions individually, but when we use <code>doseq</code> to iterate <code>report</code> over multiple functions, it’s a worthless failure. Here’s what a macro expansion for one of the <code>doseq</code> iterations would look like:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">if</span>
 <span class="tok-nv">code</span>
 <span class="tok-p">(</span><span class="tok-nf">clojure.core/println</span> <span class="tok-ss">'code</span> <span class="tok-s">"was successful:"</span> <span class="tok-nv">code</span><span class="tok-p">)</span>
 <span class="tok-p">(</span><span class="tok-nf">clojure.core/println</span> <span class="tok-ss">'code</span> <span class="tok-s">"was not successful:"</span> <span class="tok-nv">code</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">As you can see, <code>report</code> receives the unevaluated symbol <code>code</code> in each iteration; however, we want it to receive whatever <code>code</code> is bound to at evaluation time. But <code>report</code>, operating at macro expansion time, just can’t access those values. It’s like it has T. rex arms, with runtime values forever out of its reach.</p>
	<p class="Body">To resolve this situation, we might write another macro, like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">doseq-macro</span>
  <span class="tok-p">[</span><span class="tok-nv">macroname</span> <span class="tok-o">&amp;</span> <span class="tok-nv">args</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-nf">do</span>
     <span class="tok-o">~@</span><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">arg</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-nv">macroname</span> <span class="tok-nv">arg</span><span class="tok-p">))</span> <span class="tok-nv">args</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">doseq-macro</span> <span class="tok-nv">report</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; (= 1 1) was successful: true</span>
<span class="tok-c1">; =&gt; (= 1 2) was not successful: false</span>
</code></pre></div></div>

	<p class="Body"><span>If you are ever in this situation, take some time to rethink your </span><span>approach. It’s easy to paint yourself into a corner, making it impossible to </span><span>accomplish anything with run-of-the-mill function calls. You’ll be stuck having to write more macros instead. Macros are extremely powerful and awesome, and you shouldn’t be afraid to use them. They turn Clojure’s facilities for working with data into facilities for creating new languages informed by your programming problems. For some programs, it’s appropriate for your code to be like 90 percent macros. As awesome as they are, they also add new composition challenges. They only really compose with each other, so by using them, you might be missing out on the other kinds of composition (functional, object-oriented) available to you in Clojure.</span></p>
	<p class="Body">We’ve now covered all the mechanics of writing a macro. Pat yourself on the back! It’s a pretty big deal!</p>
	<p class="Body">To close out this chapter, it’s finally time to put on your pretending cap and work on that online potion store I talked about at the very beginning of the chapter.</p>
	<h2>Brews for the Brave and True</h2>
        <img src="/assets/images/cftbat/writing-macros/wizard.png" class="right" />
	<p class="BodyFirst">At the beginning of this chapter, I revealed a dream: to find some kind of drinkable that, once ingested, would temporarily give me the power and temperament of an ’80s fitness guru, freeing me from a prison of inhibition and self-awareness. I’m sure that someone somewhere will someday invent such an elixir, so we might as well get to work on a system for selling this mythical potion. Let’s call this hypothetical concoction the <em>Brave and True Ale</em>. The name just came to me for no reason whatsoever.</p>
	<p class="Body">Before the orders come <em>pouring</em> in (pun! high-five!), we’ll need to have some validation in place. This section shows you a way to do this validation functionally and how to write the code that performs validations a bit more concisely using a macro you’ll write called <code>if-valid</code>. This will help you understand a typical situation for writing your own macro. If you just want the macro definition, it’s okay to skip ahead to <a href="#Anchor">“<code>if-valid</code>” on page <span>182</span></a>.</p>
	<h3>Validation Functions</h3>
	<p class="BodyFirst">To keep things simple, we’ll just worry about validating the name and email for each order. For our store, I’m thinking we’ll want to have those order details represented like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">order-details</span>
  <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Mitchard Blimmons"</span>
   <span class="tok-ss">:email</span> <span class="tok-s">"mitchard.blimmonsgmail.com"</span><span class="tok-p">})</span>
</code></pre></div></div>

	<p class="Body"> This particular map has an invalid email address (it’s missing the <code>@</code> symbol), so this is exactly the kind of order that our validation code should catch! Ideally, we want to write code that produces something like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">validate</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validations</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; {:email ["Your email address doesn't look like an email address."]}</span>
</code></pre></div></div>

	<p class="Body">That is, we want to be able to call a function, <code>validate</code>, with the data that needs validation and a definition for how to validate it. The result should be a map where each key corresponds to an invalid field, and each value is a vector of one or more validation messages for that field. The following two functions do the job.</p>
	<p class="Body">Let’s look at <code>order-details-validations</code> first. Here’s how you could represent validations:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">order-details-validations</span>
  <span class="tok-p">{</span><span class="tok-ss">:name</span>
   <span class="tok-p">[</span><span class="tok-s">"Please enter a name"</span> <span class="tok-nv">not-empty</span><span class="tok-p">]</span>

   <span class="tok-ss">:email</span>
   <span class="tok-p">[</span><span class="tok-s">"Please enter an email address"</span> <span class="tok-nv">not-empty</span>

    <span class="tok-s">"Your email address doesn't look like an email address"</span>
    <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">or </span><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">%</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">re-seq </span><span class="tok-o">#</span><span class="tok-s">"@"</span> <span class="tok-nv">%</span><span class="tok-p">))]})</span>
</code></pre></div></div>

	<p class="Body">This is a map where each key is associated with a vector of error message and validating function pairs. For example, <code>:name</code> has one validating function, <code>not-empty</code>; if that validation fails, you should get the <code>"Please enter a name"</code> error message.</p>
	<p class="Body">Next, we need to write out the <code>validate</code> function. The <code>validate</code> function can be decomposed into two functions: one to apply validations to a single field and another to accumulate those error messages into a final map of error messages like <code>{:email ["Your email address doesn't look like an email address."]}</code>. Here’s a function called <code>error-messages-for</code> that applies validations to a single value:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">error-messages-for</span>
  <span class="tok-s">"Return a seq of error messages"</span>
  <span class="tok-p">[</span><span class="tok-nv">to-validate</span> <span class="tok-nv">message-validator-pairs</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">map first </span><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">not </span><span class="tok-p">((</span><span class="tok-nb">second </span><span class="tok-nv">%</span><span class="tok-p">)</span> <span class="tok-nv">to-validate</span><span class="tok-p">))</span>
                     <span class="tok-p">(</span><span class="tok-nf">partition</span> <span class="tok-mi">2</span> <span class="tok-nv">message-validator-pairs</span><span class="tok-p">))))</span>
</code></pre></div></div>

	<p class="Body">The first argument, <code>to-validate</code>, is the field you want to validate. The second argument, <code>message-validator-pairs</code>, should be a seq with an even number of elements. This seq gets grouped into pairs with <code>(partition 2 message-validator-pairs)</code>. The first element of the pair should be an error message, and the second element of the pair should be a function (just like the pairs are arranged in <code>order-details-validation</code>). The <code>error-messages-for</code> <span>function works by filtering out all error message and validation pairs where </span><span>the validation function returns </span><code>true</code><span> when applied to </span><code>to-validate</code><span>. It then </span>uses <code>map first</code> to get the first element of each pair, the error message. Here it is in action:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">error-messages-for</span> <span class="tok-s">""</span> <span class="tok-p">[</span><span class="tok-s">"Please enter a name"</span> <span class="tok-nv">not-empty</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; ("Please enter a name")</span>
</code></pre></div></div>

	<p class="Body">Now we need to accumulate these error messages in a map. </p>
	<p class="Body">Here’s the complete <code>validate</code> function, as well as the output when we apply it to our <code>order-details</code> and <code>order-details-validations</code>:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">validate</span>
  <span class="tok-s">"Returns a map with a vector of errors for each key"</span>
  <span class="tok-p">[</span><span class="tok-nv">to-validate</span> <span class="tok-nv">validations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">errors</span> <span class="tok-nv">validation</span><span class="tok-p">]</span>
            <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[[</span><span class="tok-nv">fieldname</span> <span class="tok-nv">validation-check-groups</span><span class="tok-p">]</span> <span class="tok-nv">validation</span>
                  <span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">to-validate</span> <span class="tok-nv">fieldname</span><span class="tok-p">)</span>
                  <span class="tok-nv">error-messages</span> <span class="tok-p">(</span><span class="tok-nf">error-messages-for</span> <span class="tok-nv">value</span> <span class="tok-nv">validation-check-groups</span><span class="tok-p">)]</span>
              <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">error-messages</span><span class="tok-p">)</span>
                <span class="tok-nv">errors</span>
                <span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">errors</span> <span class="tok-nv">fieldname</span> <span class="tok-nv">error-messages</span><span class="tok-p">))))</span>
          <span class="tok-p">{}</span>
          <span class="tok-nv">validations</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">validate</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validations</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; {:email ("Your email address doesn't look like an email address")}</span>
</code></pre></div></div>

	<p class="Body">Success! This works by reducing over <code>order-details-validations</code> and associating the error messages (if there are any) for each key of <code>order-details</code> into a final map of error messages.</p>
	<h3><a id="Anchor"></a>if-valid</h3>
	<p class="BodyFirst"><span>With our validation code in place, we can now validate records to our </span>hearts’ content! Most often, validation will look something like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">errors</span> <span class="tok-p">(</span><span class="tok-nf">validate</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validations</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">errors</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:success</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:failure</span> <span class="tok-nv">errors</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">The pattern is to do the following:</p>
	<ol class="List-1">
	  <li class="NumListA">Validate a record and bind the result to <code>errors</code></li>
	  <li class="NumListB">Check whether there were any errors</li>
	  <li class="NumListB">If there were no errors, do the success thing, here <code>(println :success)</code></li>
	  <li class="NumListC">Otherwise, do the failure thing, here <code>(println :failure errors)</code></li>
	</ol>
	<p class="Body">I’ve actually used this validation code in real production websites. At first, I found myself repeating minor variations of the code over and over, a sure sign that I needed to introduce an abstraction that would hide the repetitive parts: applying the <code>validate</code> function, binding the result to some symbol, and checking whether the result is empty. To create this abstraction, you might be tempted to write a function like this:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">if-valid</span>
  <span class="tok-p">[</span><span class="tok-nv">record</span> <span class="tok-nv">validations</span> <span class="tok-nv">success-code</span> <span class="tok-nv">failure-code</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">errors</span> <span class="tok-p">(</span><span class="tok-nf">validate</span> <span class="tok-nv">record</span> <span class="tok-nv">validations</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-nv">errors</span><span class="tok-p">)</span>
      <span class="tok-nv">success-code</span>
      <span class="tok-nv">failure-code</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">However, this wouldn’t work, because <code>success-code</code> and <code>failure-code</code> would get evaluated each time. A macro would work because macros let you control evaluation. Here’s how you’d use the macro:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">if-valid</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validation</span> <span class="tok-nv">errors</span>
 <span class="tok-p">(</span><span class="tok-nf">render</span> <span class="tok-ss">:success</span><span class="tok-p">)</span>
 <span class="tok-p">(</span><span class="tok-nf">render</span> <span class="tok-ss">:failure</span> <span class="tok-nv">errors</span><span class="tok-p">))</span>
</code></pre></div></div>

	<p class="Body">This macro hides the repetitive details and helps you express your intention more succinctly. It’s like asking someone to give you the bottle opener instead of saying, “Please give me the manual device for removing the temporary sealant from a glass container of liquid.” Here’s the implementation:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmacro </span><span class="tok-nv">if-valid</span>
  <span class="tok-s">"Handle validation more concisely"</span>
  <span class="tok-p">[</span><span class="tok-nv">to-validate</span> <span class="tok-nv">validations</span> <span class="tok-nv">errors-name</span> <span class="tok-o">&amp;</span> <span class="tok-nv">then-else</span><span class="tok-p">]</span>
  <span class="tok-o">`</span><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-o">~</span><span class="tok-nv">errors-name</span> <span class="tok-p">(</span><span class="tok-nf">validate</span> <span class="tok-o">~</span><span class="tok-nv">to-validate</span> <span class="tok-o">~</span><span class="tok-nv">validations</span><span class="tok-p">)]</span>
     <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">empty?</span> <span class="tok-o">~</span><span class="tok-nv">errors-name</span><span class="tok-p">)</span>
       <span class="tok-o">~@</span><span class="tok-nv">then-else</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body">This macro takes four arguments: <code>to-validate</code>, <code>validations</code>, <code>errors-name</code>, and the rest argument <code>then-else</code>. Using <code>errors-name</code> like this is a new strategy. We want to have access to the errors returned by the <code>validate</code> function within the <code>then-else</code> statements. To do this, we tell the macro what symbol it should bind the result to. The following macro expansion shows how this works:</p>
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"> <span class="tok-p">(</span><span class="tok-nf">macroexpand</span>
 <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nf">if-valid</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validations</span> <span class="tok-nv">my-error-name</span>
            <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:success</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:failure</span> <span class="tok-nv">my-error-name</span><span class="tok-p">)))</span>
<span class="tok-p">(</span><span class="tok-nf">let*</span>
 <span class="tok-p">[</span><span class="tok-nv">my-error-name</span> <span class="tok-p">(</span><span class="tok-nf">user/validate</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validations</span><span class="tok-p">)]</span>
 <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nf">clojure.core/empty?</span> <span class="tok-nv">my-error-name</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:success</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-ss">:failure</span> <span class="tok-nv">my-error-name</span><span class="tok-p">)))</span>
</code></pre></div></div>

	<p class="Body"><span>The syntax quote abstracts the general form of the </span><code>let/validate/if </code><span>pattern you saw earlier. Then we use unquote splicing to unpack the </span><code>if</code><span> </span>branches, which were packed into the <code>then-else</code> rest argument.</p>
	<p class="Body">That’s pretty simple! After all this talk about macros and going through their mechanics in such detail, I bet you were expecting something more complicated. Sorry, friend. If you’re having a hard time coping with your disappointment, I know of a certain drink that will help.</p>
	<h2>Summary</h2>
	<p class="BodyFirst"><span>In this chapter, you learned how to write your own macros. Macros are </span><span>defined very similarly to functions: they have arguments, a docstring, and a </span>body. They can use argument destructuring and rest args, and they can be recursive. Your macros will almost always return lists. You’ll sometimes use <code>list</code> and <code>seq</code> functions for simple macros, but most of the time you’ll use the syntax quote, <code>`</code>, which lets you write macros using a safe template.</p>
	<p class="Body">When you’re writing macros, it’s important to keep in mind the distinction between symbols and values: macros are expanded before code is evaluated and therefore don’t have access to the results of evaluation. Double evaluation and variable capture are two other subtle traps for the unwary, but you can avoid them through the judicious use of <code>let</code> expressions and gensyms.</p>
	<p class="Body">Macros are fun tools that allow you to code with fewer inhibitions. By letting you control evaluation, macros give you a degree of freedom and expression that other languages simply don’t allow. Throughout your Clojure journey, you’ll probably hear people cautioning you against their use, saying things like “Macros are evil” and “You should never use <span>macros</span>.” Don’t listen to these prudes—at least, not at first! Go out there and have a good time. That’s the only way you’ll learn the situations where it’s appropriate to use macros. You’ll come out the other side knowing how to use macros with skill and panache.</p>
	<h2>Exercises</h2>
	<ol class="List-1">
	  <li class="NumListA">Write the macro <code>when-valid</code> so that it behaves similarly to <code>when</code>. Here is an example of calling it: 
	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">when-valid</span> <span class="tok-nv">order-details</span> <span class="tok-nv">order-details-validation</span>
 <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"It's a success!"</span><span class="tok-p">)</span>
 <span class="tok-p">(</span><span class="tok-nf">render</span> <span class="tok-ss">:success</span><span class="tok-p">))</span>
</code></pre></div></div>

	<dd>When the data is valid, the <code>println</code> and <code>render</code> forms should be evaluated, and <code>when-valid</code> should return <code>nil</code> if the data is invalid.</dd>
        </li>
	  <li class="NumListB">You saw that <code>and</code> is implemented as a macro. Implement <code>or</code> as a macro.</li>
	  <li class="NumListC para-style-override-2">In Chapter 5 you created a series of functions (<code>c-int</code>, <code>c-str</code>, <code>c-dex</code>) to read an RPG character’s attributes. Write a macro that defines an arbitrary number of attribute-retrieving functions using one macro call. Here’s how you would call it:

	<div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">defattrs</span> <span class="tok-nv">c-int</span> <span class="tok-ss">:intelligence</span>
          <span class="tok-nv">c-str</span> <span class="tok-ss">:strength</span>
          <span class="tok-nv">c-dex</span> <span class="tok-ss">:dexterity</span><span class="tok-p">)</span>
</code></pre></div></div>

        </li>
        </ol>
      
    </div>
  

