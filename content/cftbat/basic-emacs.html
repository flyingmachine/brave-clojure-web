---
title: "How to Use Emacs, an Excellent Clojure Editor"
kind: chapter
---
      <div class="chapter-number">Chapter 2</div>
      <h1>How to Use Emacs, an Excellent Clojure Editor</h1>
      <p class="x1st-Para">On your journey to Clojure mastery, your editor will be your closest ally. I highly recommend working with Emacs, but you can, of course, use any editor you want. If you don’t follow the thorough Emacs instructions in this chapter, or if you choose to use a different editor, it’s worthwhile to at least invest some time in setting up your editor to work with a REPL.</p>
      <p class="Body">The reason I recommend Emacs is that it offers tight integration with a Clojure REPL, which allows you to instantly try out your code as you write. That kind of tight feedback loop will be useful while learning Clojure and, later, when writing real Clojure programs. Emacs is also great for working with any Lisp dialect; in fact, Emacs is written in a Lisp dialect called Emacs Lisp (elisp). </p>
      <p class="Body">By the end of this chapter, your Emacs setup will look something like Figure 2-1.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-final.png" />
      
	<div class="caption">Figure 2-1: A typical Emacs setup for working with Clojure—code on one side, REPL on the other</div>
      
      <p class="Body">To get there, you’ll start by installing Emacs and setting up a new-person-friendly Emacs configuration. Then you’ll learn the basics: how to open, edit, and save files, and how to interact with Emacs using essential key bindings. Finally, you’ll learn how to actually edit Clojure code and interact with the REPL.</p>
      <h2>Installation</h2>
      <p class="BodyFirst">You should use the latest major version of Emacs, Emacs 24, for the platform you’re working on:</p>
      <ul class="list-plain"><li><strong>OS X</strong> Install vanilla Emacs as a Mac app from <em><a href="http://emacsformacosx.com">http://emacsformacosx.com</a></em><span>. Other options, like Aquamacs, are supposed to make Emacs more “Mac-like,” but they’re problematic in the long run because </span>they’re set up so differently from standard Emacs that it’s difficult to use the Emacs manual or follow along with tutorials.</li>
      <li><strong>Ubuntu</strong> Follow the instructions at <em><a href="https://launchpad.net/~cassou/+archive/emacs">https://launchpad.net/~cassou/+archive/emacs</a></em>.</li>
      <li><strong>Windows</strong> <span>You can find a binary </span>at <em><a href="http://ftp.gnu.org/gnu/emacs/windows/">http://ftp.gnu.org/gnu/emacs/windows/</a></em>. After you download and unzip the latest version, you can run the Emacs executable under <em>bin\runemacs.exe</em>.</li></ul>
      <p class="Body">After you’ve installed Emacs, open it. You should see something like Figure 2-2.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-fresh.png" />
      
	<div class="caption">Figure 2-2: The screen Emacs displays when you open it for the first time</div>
      
      <p class="Body">Welcome to the cult of Emacs! You’ve made Richard Stallman proud!</p>
      <h2><a id="Anchor"></a>Configuration</h2>
      <p class="BodyFirst"><span>I’ve created a repository of</span><span> all the files you need to configure Emacs for Clojure, available at <em><a href="https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip">https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip</a></em>. Do </span>the following to delete your existing Emacs configuration and install the Clojure-friendly one:</p>
      <ol class="List-1">
	<li class="NumListA para-style-override-2">Close Emacs.</li>
        <li class="NumListB">Delete <em>~/.emacs</em> or <em>~/.emacs.d</em> if they exist. (Windows users, your emacs files will probably live in <em>C:\Users\your_user_name\AppData\Roaming\</em>. So, for example, you would delete <em>C:\Users\jason\AppData\Roaming\.emacs.d</em>.) This is where Emacs looks for configuration files, and deleting these files and directories will ensure that you start with a clean slate.</li>
	<li class="NumListB"><span>Download the Emacs configuration zip file listed above and unzip it. Its contents should be a folder, </span><em>emacs-for-clojure-book1</em><span>. Run </span><span class="LiteralBold">mv path/to/emacs-for-</span><span class="LiteralBold">clojure</span><span class="LiteralBold">-book1 ~/.emacs.d</span><span>.</span></li>
	<li class="NumListB">Create the file <em>~/.lein/profiles.clj</em> (Windows users, this is probably <em>C:\Users\your_user_name\.lein\profiles.clj</em>) and add this line to it: </li>
      </ol>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">{</span><span class="tok-ss">:user</span> <span class="tok-p">{</span><span class="tok-ss">:plugins</span> <span class="tok-p">[[</span><span class="tok-nv">cider/cider-nrepl</span> <span class="tok-s">"0.8.1"</span><span class="tok-p">]]}}</span> 
</code></pre></div></div>

      <ol class="List-1" start="5">
	<li class="NumListC para-style-override-4">Open Emacs.</li>
      </ol>
      <p class="Body">When you open Emacs, you may see a lot of activity as Emacs downloads a bunch of useful packages. Once the activity stops, go ahead and just quit Emacs, and then open it again. (If you don't see any activity, that's OK! Quit and restart Emacs just for funsies.) After you do so, you should see a window like the one in Figure 2-3.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-configged.png" />
      
	<div class="caption">Figure 2-3: How Emacs looks after installing your sweet new configuration</div>
      
      <p class="Body">Now that we’ve got everything set up, let’s learn how to use Emacs!</p>
      <h2>Emacs Escape Hatch</h2>
      <p class="BodyFirst">Before we dig in to the fun stuff, you need to know an important Emacs key binding: <span class="Keycap">ctrl</span>-G. This key binding quits whatever Emacs command you’re trying to run. So if things aren’t going right, hold down <span class="Keycap">ctrl</span>, press G, and then try again. It won’t close Emacs or make you lose any work; it’ll just <span>cancel</span> your current action.</p>
      <h2>Emacs Buffers</h2>
      <p class="BodyFirst">All editing happens in an Emacs <em>buffer</em>. When you first start Emacs, a buffer named <code>*scratch*</code> is open. Emacs will always show you the name of the current buffer at the bottom of the window, as shown in Figure 2-4.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-buffer-name.png" />
      
	<div class="caption">Figure 2-4: Emacs will always show you the name of the current buffer.</div>
      
      <p class="Body">By default, the<code> *scratch* </code>buffer handles parentheses and indentation in a way that’s optimal for Lisp development but is inconvenient for writing plain text. Let’s create a fresh buffer so we can play around without having unexpected things happen. To create a buffer, do this:</p>
      <ol class="List-1">
	<li class="NumListA">Hold down <span class="Keycap">ctrl</span> and press X.</li>
	<li class="NumListB">Release <span class="Keycap">ctrl</span>.</li>
	<li class="NumListC">Press B.</li>
      </ol>
      <p class="Body">We can express the same sequence in a more compact format: <strong>C-x b</strong>.</p>
      <p class="Body">After performing this key sequence, you’ll see a prompt at the bottom of the application, as shown in Figure 2-5.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-buffer-prompt.png" />
      
	<div class="caption">Figure 2-5: The minibuffer is where Emacs prompts you for input.</div>
      
      <p class="Body">This area is called the <em>minibuffer</em>, and it is where Emacs prompts you for input. Right now it’s prompting us for a buffer name. You can enter the name of a buffer that is already open, or you can enter a new buffer name. Type in<span class="LiteralBold"> emacs-fun-times</span> and press <span class="Keycap">enter</span>. You should now see a completely blank buffer and can just start typing. You’ll find that keys mostly work the way you’d expect. Characters appear as you type them. The up, down, left, <span>and right arrow keys move you as you’d expect, and </span><span class="Keycap">enter</span><span> creates a new line.</span></p>
      <p class="Body">You’ll also notice that you’re not suddenly sporting a bushy Unix beard or Birkenstocks (unless you had them to begin with). This should help ease <span>any lingering trepidation you feel about using Emacs. When you’re done messing around, go ahead and </span><em>kill</em><span> the buffer by typing </span><strong>C-x k enter</strong><span>. (It </span>might come as a surprise, but Emacs is actually quite violent, making ample use of the term <em>kill</em>.)</p>
      <p class="Body"><span>Now that you’ve killed the </span><code>emacs-fun-times</code><span> buffer, you should be back in the </span><code>*scratch*</code><span> buffer. In general, you can create as many new buffers as you want with </span><strong>C-x b</strong><span>. You can also quickly switch between buffers using the same command. When you create a new buffer this way, it exists only in memory until you save it as a file; buffers aren’t necessarily backed by files, and </span><span>creating</span><span> a buffer doesn’t necessarily create a file. Let’s learn about working with files.</span></p>
      <h2>Working with Files</h2>
      <p class="BodyFirst"><span>The key binding for opening a file in Emacs is </span><strong>C-x C-f</strong><span>.</span><strong> </strong><span>Notice that you’ll need to hold down </span><span class="Keycap">ctrl</span><span> when pressing both X and </span><span>F. After you do that, </span>you’ll get another minibuffer prompt. Navigate to <em>~/.emacs.d/customizations/ui.el</em>, which customizes the way Emacs looks and how you can interact with it. Emacs opens the file in a new buffer with the same name as the filename. Let’s go to line 37 and uncomment it by removing the leading semicolons. It will look like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">setq</span> <span class="tok-nv">initial-frame-alist</span> <span class="tok-o">'</span><span class="tok-p">((</span><span class="tok-nf">top</span> <span class="tok-k">. </span><span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">left </span><span class="tok-k">. </span><span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">width</span> <span class="tok-k">. </span><span class="tok-mi">120</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">height</span> <span class="tok-k">. </span><span class="tok-mi">80</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body">Then change the values for <code>width</code> and <code>height</code>, which set the dimensions in <em>characters</em> for the active window. By changing these values, you can set the Emacs window to open at a certain size every time it starts. Try something small at first, like 80 and 20:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">setq</span> <span class="tok-nv">initial-frame-alist</span> <span class="tok-o">'</span><span class="tok-p">((</span><span class="tok-nf">top</span> <span class="tok-k">. </span><span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">left </span><span class="tok-k">. </span><span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">width</span> <span class="tok-k">. </span><span class="tok-mi">80</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">height</span> <span class="tok-k">. </span><span class="tok-mi">20</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body">Now save your file with the following key binding: <strong>C-x C-s</strong>.<strong> </strong>You should <span>get a message at the bottom of Emacs like </span><code>Wrote /Users/snuffleupagus/</code><code>.emacs.d/customizations/ui.el</code>. You can also try saving your buffer using the <span>key binding you use in other applications (for example, </span><span class="Keycap">ctrl</span><span>-S or </span><span class="Apple">cmd</span><span>-S). The Emacs configuration you downloaded should allow that to work, but if it doesn’t, it’s no big deal.</span></p>
      <p class="Body">After saving the file, quit Emacs and start it again. I bet it’s very tiny! See my example in Figure 2-6.</p>
      <img src="/assets/images/cftbat/basic-emacs/tinemacs.png" width="300"/>
      
	<div class="caption">Figure 2-6: You can configure Emacs to set its height and width every time you open it.</div>
      
      <p class="Body"><span>Go through that same process a couple of times until Emacs starts at a size that you like. Or just comment out those lines again and be done with it (in which case Emacs will open at its default width and height). </span>If you’re done editing <em>ui.el</em>, you can close its buffer with <strong>C-x k</strong>. Either way, <span>you’re done saving your first file in Emacs! If something crazy happens, </span><span>you can follow the instructions in </span><a href="#Anchor"><span>“Configuration” on page </span><span>13</span></a><span> to get Emacs </span>working again.</p>
      <p class="Body">If you want to create a new file, just use <strong>C-x C-f</strong> and enter the new file’s path in the minibuffer. As soon as you save the buffer, Emacs will create a file with the buffer’s contents at the path you entered.</p>
      <p class="Body">Let’s recap:</p>
      <ol class="List-1">
	<li class="NumListA">In Emacs, editing takes place in buffers<em>.</em></li>
	<li class="NumListB">To switch to a buffer, use <strong>C-x b</strong> and enter the buffer name in the minibuffer<em>.</em></li>
	<li class="NumListB">To create a new buffer, use <strong>C-x b</strong> and enter a new buffer name.</li>
	<li class="NumListB">To open a file, use <strong>C-x C-f</strong> and navigate to the file.</li>
	<li class="NumListB">To save a buffer to a file, use <strong>C-x C-s</strong>.</li>
	<li class="NumListB">To create a new file, use <strong>C-x C-f</strong> and enter the new file’s path. When you save the buffer, Emacs will create the file on the filesystem.</li>
      </ol>
      <h2>Key Bindings and Modes</h2>
      <p class="BodyFirst">You’ve already come a long way! You can now use Emacs like a very basic editor. This should help you get by if you ever need to use Emacs on a server or are forced into pairing with an Emacs nerd.</p>
      <p class="Body">However, to really be productive, it’ll be useful for you to know some <em>key</em> details about key bindings (ha-ha!). Then I’ll introduce Emacs modes. After that, I’ll cover some core terminology and go over a bunch of super useful key bindings.</p>
      <h3>Emacs Is a Lisp Interpreter</h3>
      <p class="BodyFirst"><span>The term </span><em>key binding</em><span> derives from the fact that Emacs binds </span><em>keystrokes</em><span> to </span><em>commands</em><span>, which are just elisp functions (I’ll use </span><em>command</em><span> and </span><em>function</em><span> inter</span>changeably). For example, <strong>C-x b </strong>is bound to the function <code>switch-to-buffer</code>. Likewise, <strong>C-x C-s</strong> is bound to <code>save-file</code>.</p>
      <p class="Body">But  Emacs goes even further than that. Even simple keystrokes like <strong>f</strong> and <strong>a</strong> are bound to a function, in this case <code>self-insert-command</code>, the command for adding characters to the buffer you’re editing.</p>
      <p class="Body">From Emacs’s point of view, all functions are created equal, and you can redefine all functions, even core functions like <code>save-file</code>. You probably won’t <em>want</em> to redefine core functions, but you can.</p>
      <p class="Body"><span>You can redefine functions because, at its core, Emacs is </span><em>just</em><span> a Lisp interpreter that happens to load code-editing facilities. Most of Emacs is written in elisp, so from the perspective of Emacs, </span><code>save-file</code><span> is just a function, as is </span><code>switch-to-buffer</code><span> and almost any other command you can run. Not only that, but any functions you create are treated the same way as built-in functions. You can even use Emacs to execute elisp, modifying Emacs as it runs.</span></p>
      <p class="Body"><span>The freedom to modify Emacs using a powerful programming language is what makes Emacs so flexible and why people like me are so crazy about it. Yes, it has a lot of surface-level complexity that can take time to learn. But underlying Emacs is the elegant simplicity of Lisp and the infinite tinkerability that comes with it. This tinkerability isn’t limited to just creating and redefining functions. You can also create, redefine, and remove key bindings. Conceptually, key bindings are just an entry in a lookup table associating keystrokes with functions, and that lookup table is completely modifiable.</span></p>
      <p class="Body">You can also run commands by name, without a specific key binding, using <strong>M-x </strong><span class="LiteralBoldItal">function-name</span> (for example, <strong>M-x </strong><span class="LiteralBold">save-buffer</span>). <em>M</em> stands for <em>meta</em>, a key that modern keyboards don’t possess but which is mapped to <span class="Keycap">alt</span> on Windows and Linux and <span class="Keycap">option </span>on Macs. <strong>M-x</strong> runs the <code>smex</code> command, which prompts you for the name of another command to be run.</p>
      <p class="Body">Now that you understand key bindings and functions, you’ll be able to understand what modes are and how they work.</p>
      <h3>Modes</h3>
      <p class="BodyFirst">An Emacs <em>mode</em> is a collection of key bindings and functions that are packaged together to help you be productive when editing different types of files. (Modes also do things like tell Emacs how to do syntax highlighting, but that’s of secondary importance, and I won’t cover that here.)</p>
      <p class="Body"><span>For example, when you’re editing a Clojure file, you’ll want to load Clojure mode. Right now I’m writing a Markdown file and using </span>Markdown mode, which has lots of useful key bindings specific to working with Markdown. When editing Clojure, it’s best to have a set of Clojure-specific key bindings, like <strong>C-c C-k</strong> to load the current buffer into a REPL and compile it.</p>
      <p class="Body">Modes come in two flavors: <em>major</em> modes and <em>minor</em> modes. Markdown mode and Clojure mode are major modes. Major modes are usually set by Emacs when you open a file, but you can also set the mode explicitly by running the relevant Emacs command, for example with<code> </code><strong>M-x </strong><span class="LiteralBold">clojure-mode</span> or <strong>M-x </strong><span class="LiteralBold">major-mode</span>. Only one major mode is active at a time.</p>
      <p class="Body"><span>Whereas major modes specialize Emacs for a certain file type or </span><span>language</span>, minor modes usually provide functionality that’s useful across file types. For example, abbrev mode “automatically expands text based on pre-defined abbreviation definitions” (per the Emacs manual<sup><a id="footnote-5680-1-backlink" class="footnote-link" href="#footnote-5680-1">1.</a></sup>). You can have multiple minor modes active at the same time.</p>
      <p class="Body">You can see which modes are active on the <em>mode line</em>, as shown in Figure 2-7.</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-mode-line.png" />
      
	<div class="para-style-override-4 caption">Figure 2-7: The mode line shows you which modes are active.</div>
      
      <p class="Body">If you open a file and Emacs doesn’t load a major mode for it, chances are that one exists. You’ll just need to download its package. Speaking of which . . .</p>
      <h3>Installing Packages</h3>
      <p class="BodyFirst">Many modes are distributed as <em>packages</em>, which are just bundles of elisp files stored in a package repository. Emacs 24, which you installed at the beginning of this chapter, makes it very easy to browse and install packages. <strong>M-x </strong><span class="LiteralBold">package-list-packages</span> will show you almost every package available; just make sure you run <strong>M-x </strong><span class="LiteralBold">package-refresh-contents</span> first so you get the latest list. You can install packages with <strong>M-x </strong><span class="LiteralBold">package-install</span>.</p>
      <p class="Body">You can also customize Emacs by loading your own elisp files or files you find on the Internet. The “Beginner’s Guide to Emacs” (found at <em><a href="http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/">http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/</a></em>) has a good description of how to load customizations under the section “Loading New Packages” toward the bottom of the article.</p>
      <h2>Core Editing Terminology and Key Bindings</h2>
      <img src="/assets/images/cftbat/basic-emacs/pirate.png" class="right" />
      <p class="BodyFirst">If all you want to do is use Emacs like a text editor, you can skip this section entirely! But you’ll be missing out on some great stuff. In this section, we’ll go over key Emacs terms; how to select, cut, copy, and paste text; how to select, cut, copy, and paste text (see what I did there? Ha ha ha!); and how to move through the buffer efficiently.</p>
      <p class="Body"><span>To get started, open a new buffer in Emacs and name it </span><em>jack-handy</em><span>. Then enter the following Jack Handy quotations:</span></p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">If</span> <span class="tok-nv">you</span> <span class="tok-nv">were</span> <span class="tok-nv">a</span> <span class="tok-nv">pirate</span>, <span class="tok-nv">you</span> <span class="tok-nv">know</span> <span class="tok-nv">what</span> <span class="tok-nv">would</span> <span class="tok-nv">be</span> <span class="tok-nv">the</span> <span class="tok-nv">one</span> <span class="tok-nv">thing</span> <span class="tok-nv">that</span> <span class="tok-nv">would</span>
<span class="tok-nv">really</span> <span class="tok-nv">make</span> <span class="tok-nv">you</span> <span class="tok-nv">mad?</span> <span class="tok-nv">Treasure</span> <span class="tok-nv">chests</span> <span class="tok-nv">with</span> <span class="tok-nv">no</span> <span class="tok-nv">handles.</span> <span class="tok-nv">How</span> <span class="tok-nv">the</span> <span class="tok-nv">hell</span> <span class="tok-nv">are</span>
<span class="tok-nv">you</span> <span class="tok-nv">supposed</span> <span class="tok-nv">to</span> <span class="tok-nv">carry</span> <span class="tok-nv">it?!</span>

<span class="tok-nv">The</span> <span class="tok-nv">face</span> <span class="tok-nv">of</span> <span class="tok-nv">a</span> <span class="tok-nv">child</span> <span class="tok-nv">can</span> <span class="tok-nv">say</span> <span class="tok-nv">it</span> <span class="tok-nv">all</span>, <span class="tok-nv">especially</span> <span class="tok-nv">the</span> <span class="tok-nv">mouth</span> <span class="tok-nv">part</span> <span class="tok-nv">of</span> <span class="tok-nv">the</span>
<span class="tok-nv">face.</span>

<span class="tok-nv">To</span> <span class="tok-nv">me</span>, <span class="tok-nv">boxing</span> <span class="tok-nv">is</span> <span class="tok-nv">like</span> <span class="tok-nv">a</span> <span class="tok-nv">ballet</span>, <span class="tok-nv">except</span> <span class="tok-nv">there</span><span class="tok-ss">'s</span> <span class="tok-nv">no</span> <span class="tok-nv">music</span>, <span class="tok-nv">no</span>
<span class="tok-nv">choreography</span>, <span class="tok-nb">and </span><span class="tok-nv">the</span> <span class="tok-nv">dancers</span> <span class="tok-nv">hit</span> <span class="tok-nv">each</span> <span class="tok-nv">other.</span>
</code></pre></div></div>

      <p class="Body">Use this example to experiment with navigation and editing in this section.</p>
      <h3>Point</h3>
      <p class="BodyFirst">If you’ve been following along, you should see a red-orange rectangle in your Emacs buffer. This is the <em>cursor</em>, and it’s the graphical representation of the <em>point</em>. Point is where all the magic happens: you insert text at point, and most editing commands happen in relation to point. And even though your cursor appears to rest on top of a character, point is actually located between that character and the previous one.</p>
      <p class="Body">For example, place your cursor over the <em>f</em> in <em>If you were a pirate</em>. Point is located between <em>I</em> and <em>f</em>. Now, if you use <strong>C-k</strong>, all the text from the letter <em>f</em> onward will disappear. <strong>C-k</strong> runs the command <code>kill-line</code>, which <em>kills</em> all text after point on the current line (I’ll talk more about killing later). Undo that change with <strong>C-/</strong>. Also, try your normal OS key binding for undo; that should work as well.</p>
      <h3>Movement</h3>
      <p class="BodyFirst">You can use your arrow keys to move point just like any other editor, but many key bindings allow you to navigate more efficiently, as shown in Table 2-1.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-1: Key Bindings for Navigating Text</li>
      </ol>
      <table id="table-1" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-a</strong>
	    </td>
	    <td class="Body">
	      Move to beginning of line.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-m</strong>
	    </td>
	    <td class="Body">
	      Move to first non-whitespace character on the line.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-e</strong>
	    </td>
	    <td class="Body">
	      Move to end of line.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-f</strong>
	    </td>
	    <td class="Body">
	      Move forward one character.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-b</strong>
	    </td>
	    <td class="Body">
	      Move backward one character.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-f</strong>
	    </td>
	    <td class="Body">
	      Move forward one word (I use this a lot).
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-b</strong>
	    </td>
	    <td class="Body">
	      Move backward one word (I use this a lot, too).
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-s</strong>
	    </td>
	    <td class="Body">
	      Regex search for text in current buffer and move to it. Press <strong>C-s</strong> again to move to next match.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-r</strong>
	    </td>
	    <td class="Body">
	      Same as <strong>C-s</strong>, but search in reverse.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-&lt;</strong>
	    </td>
	    <td class="Body">
	      Move to beginning of buffer.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-&gt;</strong>
	    </td>
	    <td class="Body">
	      Move to end of buffer.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>M-g g</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Go to line.
	    </td>
	  </tr>
	</tbody>
      </table>
      <p class="Body">Go ahead and try out these key bindings in your <em>jack-handy</em> buffer!</p>
      <h3>Selection with Regions</h3>
      <p class="BodyFirst">In Emacs, we don’t <em>select</em> text. We create <em>regions</em>, and we do so by setting the <em>mark</em> with <strong>C-spc </strong>(<span class="Keycap">ctrl</span>-spacebar). Then, when you move point, everything between mark and point is the region. It’s very similar to <span class="Keycap">shift</span>-selecting text for basic purposes. </p>
      <p class="Body">For example, do the following in your <em>jack-handy</em> buffer:</p>
      <ol class="List-1">
	<li class="NumListA">Go to the beginning of the file.</li>
	<li class="NumListB">Use <strong>C-spc</strong>.</li>
	<li class="NumListB">Use <strong>M-f</strong> twice. You should see a highlighted region encompassing <em>If you</em>.</li>
	<li class="NumListC">Press backspace. That should delete <em>If you</em>.</li>
      </ol>
      <p class="Body">One cool thing about using mark instead of Shift-selecting text is that <span>you’re free to use all of Emacs’s movement commands after you set the mark. For example, you could set a mark and then use </span><strong>C-s</strong><span> to search for some bit of text hundreds of lines down in your buffer. Doing so would </span><span>create</span> a very large region, and you wouldn’t have to strain your pinky holding down <span class="Keycap">shift</span>.</p>
      <p class="Body"><span>Regions also let you confine an operation to a limited area of the buffer. </span>Try this:</p>
      <ol class="List-1">
	<li class="NumListA">Create a region encompassing <em>The face of a child can say it all</em>.</li>
	<li class="NumListC">Use <strong>M-x </strong><span class="LiteralBold">replace-string</span> and replace <em>face</em> with <em>head</em>.</li>
      </ol>
      <p class="Body">This will perform the replacement within the current region rather than the entire buffer after point, which is the default behavior.</p>
      <h3>Killing and the Kill Ring</h3>
      <p class="BodyFirst">In most applications we can <em>cut</em> text, which is only mildly violent. We can also <em>copy</em> and<em> paste</em>. Cutting and copying add the selection to the clipboard, and pasting copies the contents of the clipboard to the current application. In Emacs, we take the homicidal approach and <em>kill</em> regions, adding them to the <em>kill ring</em>. Don’t you feel <em>braver</em> and <em>truer</em> knowing that you’re laying waste to untold kilobytes of text? We can then <em>yank</em>, inserting the most recently killed text at point. We can also <em>copy</em> text to the kill ring without actually killing it.</p>
      <p class="Body">Why bother with all this morbid terminology? Well, first, so you won’t <span>be frightened when you hear someone talking about killing things in Emacs. </span>But more important, Emacs allows you to do tasks that you can’t do with the typical cut/copy/paste clipboard featureset.</p>
      <p class="Body">Emacs stores multiple blocks of text on the kill ring, and you can cycle through them. This is cool because you can cycle through to retrieve text you killed a long time ago. Let’s see this in action:</p>
      <ol class="List-1">
	<li class="NumListA">Create a region over the word <em>Treasure</em> in the first line.</li>
	<li class="NumListB">Use <strong>M-w</strong>, which is bound to the <code>kill-ring-save</code> command. In general, <strong>M-w</strong> is like copying. It adds the region to the kill ring without deleting it from your buffer.</li>
	<li class="NumListB">Move point to the word <em>choreography</em> on the last line.</li>
	<li class="NumListB"><span>Use </span><strong>M-d</strong><span>, which is bound to the </span><code>kill-word</code><span> command. This adds </span><em>choreogra</em><em>phy</em> to the kill ring and deletes it from your buffer.</li>
	<li class="NumListB">Use <strong>C-y</strong>. This will yank the text you just killed, <em>choreography</em>, inserting it at point.</li>
	<li class="NumListC">Use <strong>M-y</strong>. This will remove <em>choreography</em> and yank the next item on the kill ring, <em>Treasure</em>.</li>
      </ol>
      <p class="Body">You can see some useful kill/yank key bindings in Table 2-2.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-2: Key Bindings for Killing and Yanking Text</li>
      </ol>
      <table id="table-2" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-w</strong>
	    </td>
	    <td class="Body">
	      Kill region.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-w</strong>
	    </td>
	    <td class="Body">
	      Copy region to kill ring.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-y</strong>
	    </td>
	    <td class="Body">
	      Yank.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-y</strong>
	    </td>
	    <td class="Body">
	      Cycle through kill ring after yanking.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-d</strong>
	    </td>
	    <td class="Body">
	      Kill word.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-k</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Kill line.
	    </td>
	  </tr>
	</tbody>
      </table>
      <h3>Editing and Help</h3>
      <p class="BodyFirst">Table 2-3 shows some additional, useful, editing key bindings you should know about for dealing with spacing and expanding text.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-3: Other Useful Editing Key Bindings</li>
      </ol>
      <table id="table-3" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>Tab</strong>
	    </td>
	    <td class="Body">
	      Indent line.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-j</strong>
	    </td>
	    <td class="Body">
	      New line and indent, equivalent to <span class="KeycapBox">enter</span> followed by <span class="KeycapBox">tab</span>.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-/</strong>
	    </td>
	    <td class="Body">
	      Hippie expand; cycles through possible expansions of the text before point.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>M-\</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Delete all spaces and tabs around point. (I use this one a lot.)
	    </td>
	  </tr>
	</tbody>
      </table>
      <p class="Body">Emacs also has excellent built-in help. The two key bindings shown in Table 2-4 will serve you well.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-4: Key Bindings for Built-in Help</li>
      </ol>
      <table id="table-4" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-h k </strong><strong>key-binding</strong>
	    </td>
	    <td class="Body">
	      Describe the function bound to the key binding. To get this to work, you actually perform the key sequence after typing <strong>C-h k</strong>.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-h f</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Describe function.
	    </td>
	  </tr>
	</tbody>
      </table>
      <p class="Body">The help text appears in a new <em>window</em>, a concept I will cover later in the chapter. For now, you can close help windows by pressing<strong> C-x o q</strong>.</p>
      <h2>Using Emacs with Clojure</h2>
      <p class="BodyFirst">Next, I’ll explain how to use Emacs to efficiently develop a Clojure application. You’ll learn how to start a REPL process that’s connected to Emacs and how to work with Emacs windows. Then I’ll cover a cornucopia of useful key bindings for evaluating expressions, compiling files, and performing other handy tasks. Finally, I’ll show you how to handle Clojure errors and introduce some features of Paredit, an optional minor mode, which is useful for writing and editing code in Lisp-style languages.</p>
      <p class="Body">If you want to start digging in to Clojure code, please do skip ahead! You can always return later.</p>
      <h3>Fire Up Your REPL!</h3>
      <p class="BodyFirst">As you learned in Chapter 1, a REPL allows you to interactively write and run Clojure code. The REPL is a running Clojure program that gives you a prompt and then reads your input, evaluates it, prints the result, and loops back to the prompt. In Chapter 1, you started the REPL in a terminal window with <code>lein repl</code>. In this section, you’ll start a REPL directly in Clojure.</p>
      <p class="Body"><span>To connect Emacs to a REPL, you’ll use the Emacs package</span>CIDER, available at <em><a href="https://github.com/clojure-emacs/cider/">https://github.com/clojure-emacs/cider/</a></em>. If you followed the configuration instructions earlier in this chapter, you should already have it installed, but you can also install it by running <strong>M-x </strong><span class="LiteralBold">package-install</span><span>, entering </span><span class="LiteralBold">cider</span><span>, and pressing </span><span class="Keycap">enter</span><span>.</span></p>
      <p class="Body"><span>CIDER allows you to start a REPL within Emacs and provides you with key bindings that allow you to interact with the REPL more efficiently. Go ahead and start a REPL session now. Using Emacs, open the file </span><em>clojure-noob/</em><em>src/clojure_noob/core.clj</em><span>, which you created in Chapter 1. </span><span>Next, use </span><strong>M-x </strong><span class="LiteralBold">cider-jack-in</span><span>. This starts the REPL and creates a new buffer where you can interact with it. After a short wait (it should be less than a minute), you should see something like Figure 2-8.</span></p>
      <img src="/assets/images/cftbat/basic-emacs/cider-jack-in.png" />
      
	<div class="caption">Figure 2-8: What your Emacs should look like after running M-x <span class="LiteralCaption">cider-jack-in</span></div>
      
      <p class="Body">Now we have two windows: our <em>core.clj</em> file is open on the left, and the REPL is running on the right. If you’ve never seen Emacs split in half like this, don’t worry! I’ll talk about how Emacs splits windows in a second. In the meantime, try evaluating some code in the REPL. Type in the following bolded lines. The result that you should see printed in the REPL when you press <span class="Keycap">enter</span> is shown after each line of code. Don’t worry about the code at this time; I’ll cover all these functions in the next chapter.</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; 10</span>
<span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; (2 3 4 5)</span>
<span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-p">[</span><span class="tok-mi">5</span> <span class="tok-mi">6</span> <span class="tok-mi">100</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; 111</span>
</code></pre></div></div>

      <p class="Body">Pretty nifty! You can use this REPL just as you used <code>lein repl</code> in the first chapter. You can also do a whole lot more, but before I go into that, I’ll explain how to work with split-screen Emacs.</p>
      <h3>Interlude: Emacs Windows and Frames</h3>
      <p class="BodyFirst">Let’s take a quick detour to talk about how Emacs handles frames and windows, and to go over some useful window-related key bindings. Feel free to skip this section if you’re already familiar with Emacs windows.</p>
      <p class="Body">Emacs was invented in, like, 1802 or something, so it uses terminology slightly different from what you’re used to. What you would normally refer to as a <em>window</em>, Emacs calls a <em>frame</em>, and the frame can be split into multiple <em>windows</em>. Splitting into multiple windows allows you to view more than one buffer at a time. You already saw this happen when you ran <code>cider-jack-in</code> (see Figure 2-9).</p>
      <img src="/assets/images/cftbat/basic-emacs/emacs-windows.png" />
      
	<div class="caption">Figure 2-9: In Emacs, a frame contains windows.</div>
      
      <p class="Body">Table 2-5 shows several key bindings for working with the frame and windows.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-5: Emacs Window Key Bindings</li>
      </ol>
      <table id="table-5" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-x o</strong>
	    </td>
	    <td class="Body">
	      Switch cursor to another window. Try this now to switch between your Clojure file and the REPL.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-x 1</strong>
	    </td>
	    <td class="Body">
	      Delete all other windows, leaving only the current window in the frame. This doesn’t close your buffers, and it won’t cause you to lose any work.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-x 2</strong>
	    </td>
	    <td class="Body">
	      Split frame above and below.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-x 3</strong>
	    </td>
	    <td class="Body">
	      Split frame side by side.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-x 0</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Delete current window.
	    </td>
	  </tr>
	</tbody>
      </table>
      <p class="Body">I encourage you to try the Emacs window key bindings. For example, put your cursor in the left window, the one with the Clojure file, and use <strong>C-x 1</strong>. The other window should disappear, and you should see only the Clojure code. Then do the following:</p>
      <ul class="List-1">
	<li class="BulletA">Use<strong> C-x 3</strong> to split the window side by side again.</li>
	<li class="BulletB">Use<strong> C-x o</strong> to switch to the right window.</li>
	<li class="BulletC">Use<strong> C-x b </strong><span class="LiteralBold">*cider-repl*</span> to switch to the CIDER buffer in the right window.</li>
      </ul>
      <p class="Body">Once you’ve experimented a bit, set up Emacs so that it contains two side-by-side windows with Clojure code on the left and the CIDER buffer on the right, as in the previous images. If you’re interested in learning more about windows and frames, the Emacs manual has a ton of info: see <em><a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows">http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows</a></em>.</p>
      <p class="Body">Now that you can navigate Emacs windows, it’s time to learn some Clojure development key bindings!</p>
      <h3>A Cornucopia of Useful Key Bindings</h3>
      <p class="BodyFirst">Now you’re ready to learn some key bindings that will reveal the true power of using Emacs for Clojure projects. These commands will let you evaluate, tweak, compile, and run code with just a few dainty keystrokes. Let’s start by going over how to quickly evaluate an expression.</p>
      <p class="Body">At the bottom of <em>core.clj</em>, add the following:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Cleanliness is next to godliness"</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">Now use <strong>C-e</strong> to navigate to the end of the line, and then use <strong>C-x C-e</strong>.<span>The text </span><code>Cleanliness is next to godliness</code><span> should appear in the CIDER buffer, </span>as shown in Figure 2-10.</p>
      <img src="/assets/images/cftbat/basic-emacs/cider-eval-last-expression.png" />
      
	<div class="caption">Figure 2-10: Instantly evaluating code from another buffer in the REPL</div>
      
      <p class="Body">The key binding <strong>C-x C-e</strong> runs the command <code>cider-eval-last-expression</code>. As the name suggests, this command sends the expression immediately preceding point to the REPL, which then evaluates the expression. You can also try <strong>C-u C-x C-e</strong>, which prints the result of the evaluation after point.</p>
      <p class="Body">Now let’s try to run the <code>-main</code> function we wrote in Chapter 1 so we can let the world know that we’re little teapots.</p>
      <p class="Body"><span>In the </span><em>core.clj</em><span> buffer, use </span><strong>C-c M-n</strong><span>. This key binding sets the </span>namespace to the namespace listed at the top of your current file, so the prompt in the right window should now read <code>clojure-noob.core&gt;</code>. I haven’t gone into detail about namespaces yet, but for now it’s enough to know that a namespace is an organizational mechanism that allows us to avoid <span>naming conflicts. Next, enter </span><span class="LiteralBold">(-main)</span><span> at the prompt. The REPL should print </span><code>I'm a little teapot!</code><span> How exciting!</span></p>
      <p class="Body">Now let’s create a new function and run it. At the bottom of <em>core.clj</em>, add the following:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">train</span>
  <span class="tok-p">[]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">"Choo choo!"</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="Body">When you’re done, save your file and use <strong>C-c C-k</strong> to compile your current file within the REPL session. (You have to compile your code for the REPL to be aware of your changes.) Now if you run <code>(train)</code> in the REPL, it will echo back <code>Choo choo!</code>.</p>
      <p class="Body">While still in the REPL, try <strong>C-↑</strong> (<span class="Keycap">ctrl</span> plus the up arrow key). <strong>C-↑</strong> and <strong>C-↓</strong> cycle through your REPL history, which includes all the Clojure expressions that you’ve asked the REPL to evaluate.</p>
      <p class="Body">Note for Mac users: by default, OS X maps <strong>C-↑</strong>, <strong>C-↓</strong>, <strong>C-←</strong>, and <strong>C-→</strong> to Mission Control commands. You can change your Mac key bindings by opening System Preferences, and then going to Keyboard<span class="MenuArrow">4</span>Shortcuts<span class="MenuArrow">4</span>Mission Control.</p>
      <p class="Body">Finally, try this:</p>
      <ol class="List-1">
	<li class="NumListA">Type <span class="LiteralBold">(-main</span> at the REPL prompt. Note the lack of a closing parenthesis.</li>
	<li class="NumListC">Press <strong>C-enter</strong>.</li>
      </ol>
      <p class="Body">CIDER should close the parenthesis and evaluate the expression. This is just a nice little convenience that CIDER provides for dealing with so many parentheses.</p>
      <p class="Body">CIDER also has a few key bindings that are great when you’re learning <span>Clojure. Pressing </span><strong>C-c C-d C-d</strong><span> will display documentation for the symbol under point, which can be a huge time-saver. When you’re done with the documentation, press </span><strong>q</strong><span> to close the documentation buffer. The key binding </span><strong>M-.</strong><span> will navigate to the source code for the symbol under point, and </span><strong>M-,</strong><span> will return you to your original buffer and position. Finally, </span><strong>C-c C-d C-a</strong><span> </span><span>lets you search for arbitrary text across function names and documentation. This is a great way to find a function when you can’t exactly remember its name.</span></p>
      <p class="Body"><span>The CIDER README (</span><em><a href="https://github.com/clojure-emacs/cider/">https://github.com/clojure-emacs/cider/</a></em><span>) has a comprehensive list of key bindings that you can learn over time, but for now, Tables 2-6 and 2-7 contain a summary of the key bindings we just went over.</span></p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-6: Clojure Buffer Key Bindings</li>
      </ol>
      <table id="table-6" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-c M-n</strong>
	    </td>
	    <td class="Body">
	      Switch to namespace of current buffer.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-x C-e</strong>
	    </td>
	    <td class="Body">
	      Evaluate expression immediately preceding point.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-c C-k</strong>
	    </td>
	    <td class="Body">
	      Compile current buffer.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-c C-d C-d</strong>
	    </td>
	    <td class="Body">
	      Display documentation for symbol under point.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-. and M-,</strong>
	    </td>
	    <td class="Body">
	      Navigate to source code for symbol under point and return to your original buffer.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-c C-d C-a</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Apropros search; find arbitrary text across function names and documentation.
	    </td>
	  </tr>
	</tbody>
      </table>
      <ol class="List-1">
	<li class="Table-Title para-style-override-2">Table 2-7: CIDER Buffer Key Bindings</li>
      </ol>
      <table id="table-7" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      <span>Description</span>
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>C-</strong><strong>↑</strong><strong>, C-</strong><strong>↓</strong>
	    </td>
	    <td class="Body">
	      <span>Cycle through REPL history.</span>
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-enter</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Close parentheses and evaluate.
	    </td>
	  </tr>
	</tbody>
      </table>
      <h3>How to Handle Errors</h3>
      <p class="BodyFirst"><span>In this section, you’ll write some buggy code so you can see how Emacs responds to it and how you can recover from the error and continue on your merry way. You’ll do this in both the REPL buffer and the </span><em>core.clj</em><span> </span><span>buffer</span><span>. Let’s start with the REPL. At the prompt, type </span><span class="LiteralBold">(map)</span><span> and press </span><span class="Keycap">enter</span><span>. You should see something like Figure 2-11.</span></p>
      <img src="/assets/images/cftbat/basic-emacs/cider-error.png" />
      
	<div class="caption para-style-override-10">Figure 2-11: This is what happens when you run bad code in the REPL.</div>
      
      <p class="Body">As you can see, calling <code>map</code> with no arguments causes Clojure to lose its mind—it shows an <code>ArityException</code> error message in your REPL buffer and <span>fills your left window with text that looks like the ravings of a madman. These ravings are the </span><em>stack trace</em><span>, which shows the function that actually </span>threw the exception, along with which function called <em>that</em> function, down the stack of function calls.</p>
      <p class="Body"><span>Clojure’s stack traces can be difficult to decipher when you’re just starting, but after a while you’ll learn to get useful information from </span><span>them. CIDER gives you a hand by allowing you to filter stack traces, which </span><span>reduces noise so you can zero in on the cause of your exception. Line 2 of the </span><code>*cider-error*</code><span> buffer has the filters Clojure, Java, REPL, Tooling, </span><span>Duplicates, and All. You can click each option to activate that filter. You can </span>also click each stack trace line to jump to the corresponding source code.</p>
      <p class="Body">Here’s how to close the stack trace in the left window:</p>
      <ol class="List-1">
	<li class="NumListA">Use <strong>C-x o</strong> to switch to the window.</li>
	<li class="NumListC">Press<strong> q</strong> to close the stack trace and go back to CIDER.</li>
      </ol>
      <p class="Body">If you want to view the error again, you can switch to the <code>*cider-error*</code> buffer. You can also get error messages when trying to compile files. To see this, go to the <em>core.clj</em> buffer, write some buggy code, and compile:</p>
      <ol class="List-1">
	<li class="NumListA">Add <code>(map)</code> to the end.</li>
	<li class="NumListC">Use <strong>C-c C-k</strong> to compile.</li>
      </ol>
      <p class="Body">You should see a <code>*cider-error*</code> buffer similar to the one you saw earlier. Again, press <strong>q</strong> to close the stack trace.</p>
      <h3>Paredit</h3>
      <p class="BodyFirst">While writing code in the Clojure buffer, you may have noticed some unexpected things happening. For example, every time you type a left parenthesis, a right parenthesis immediately gets inserted.</p>
      <p class="Body">This occurs thanks to <em>paredit-mode</em>, a minor mode that turns Lisp’s profusion of parentheses from a liability into an asset. Paredit ensures that all parentheses, double quotes, and brackets are closed, relieving you of that odious burden.</p>
      <p class="Body">Paredit also offers key bindings to easily navigate and alter the structure created by all those parentheses. In the next section, I’ll go over the <span>most useful key bindings, but you can also check out a comprehensive </span>cheat sheet at <em><a href="https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf">https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf</a></em>(in the cheat sheet, the red pipe represents point).</p>
      <p class="Body">However, if you’re not used to it, paredit can sometimes be annoying. I think it’s more than worth your while to take some time to learn it, but you can always disable it with <strong>M-x</strong> <span class="LiteralBold">paredit-mode</span>, which toggles the mode on and off. </p>
      <p class="Body">The following section shows you the most useful key bindings. </p>
      <h4>Wrapping and Slurping</h4>
      <p class="BodyFirst"><em>Wrapping</em> surrounds the expression after point with parentheses. <em>Slurping</em> moves a closing parenthesis to include the next expression to the right. For example, say we start with this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="BodyFirst">and we want to get this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">We can wrap the <code>2</code>, add an asterisk, and then slurp the <code>3</code>. First, place point, which is represented here as a vertical pipe, <code>|</code>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-err">|</span><span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">Then type <strong>M-(</strong>, the binding for <em>paredit-wrap-round</em>, getting this result:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-err">|</span><span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">Add the asterisk and a space:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-err">|</span><span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">To slurp in the <code>3</code>, press <strong>C-&rarr;</strong>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-err">|</span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">This makes it easy to add and extend parentheses without wasting precious moments holding down arrow keys to move point.</p>
      <h4>Barfing</h4>
      <p class="BodyFirst">Suppose, in the preceding example, you accidentally slurped the four. To unslurp it (also known as <em>barfing</em>), place your cursor (<code>|</code>) anywhere in the inner parentheses:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-err">|</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="Body">Then use <strong>C-&larr;</strong>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-p">(</span><span class="tok-err">|</span><span class="tok-nb">* </span><span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">Ta-da! Now you know how to expand and contract parentheses at will.</p>
      <h4>Navigation</h4>
      <p class="BodyFirst">Often when writing in a Lisp dialect, you’ll work with expressions like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-nb">comp </span><span class="tok-nv">record</span> <span class="tok-nv">first</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">d/q</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-ss">:find</span> <span class="tok-nv">?post</span>
            <span class="tok-ss">:in</span> <span class="tok-nv">$</span> <span class="tok-nv">?search</span>
            <span class="tok-ss">:where</span>
            <span class="tok-p">[(</span><span class="tok-nf">fulltext</span> <span class="tok-nv">$</span> <span class="tok-ss">:post/content</span> <span class="tok-nv">?search</span><span class="tok-p">)</span>
             <span class="tok-p">[[</span><span class="tok-nv">?post</span> <span class="tok-nv">?content</span><span class="tok-p">]]]]</span>
          <span class="tok-p">(</span><span class="tok-nf">db/db</span><span class="tok-p">)</span>
          <span class="tok-p">(</span><span class="tok-ss">:q</span> <span class="tok-nv">params</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body">With this kind of expression, it’s useful to jump quickly from one sub­expression to the next. If you put point right before an opening parenthesis, <strong>C-M-f</strong> will take you to the closing parenthesis. Similarly, if point is right after a closing parenthesis, <strong>C-M-b</strong> will take you to the opening parenthesis.</p>
      <p class="Body">Table 2-8 summarizes the paredit key bindings you just learned.</p>
      <ol class="List-1">
	<li class="Table-Title">Table 2-8: Paredit Key Bindings</li>
      </ol>
      <table id="table-8" class="NSP-Standard-Table">
	<thead>
	  <tr>
	    <th>
	      Keys
	    </th>
	    <th>
	      Description
	    </th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td class="Body">
	      <strong>M-x</strong> <span class="LiteralBold">paredit-mode</span>
	    </td>
	    <td class="Body">
	      Toggle paredit mode.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>M-(</strong>
	    </td>
	    <td class="Body">
	      Surround expression after point in parentheses (paredit-wrap-round).
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-</strong><span class="char-style-override-2">→</span>
	    </td>
	    <td class="Body">
	      Slurp; move closing parenthesis to the right to include next expression.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body">
	      <strong>C-</strong><span class="char-style-override-2">←</span>
	    </td>
	    <td class="Body">
	      Barf; move closing parenthesis to the left to exclude last expression.
	    </td>
	  </tr>
	  <tr>
	    <td class="Body-Footer-Row">
	      <strong>C-M-f</strong>, <strong>C-M-b</strong>
	    </td>
	    <td class="Body-Footer-Row">
	      Move to the opening/closing parenthesis.
	    </td>
	  </tr>
	</tbody>
      </table>
      <h2>Continue Learning</h2>
      <p class="BodyFirst">Emacs is one of the longest-lived editors, and its adherents often approach fanaticism in their enthusiasm for it. It can be awkward to use at first, but stick with it and you will be amply rewarded over your lifetime.</p>
      <p class="Body">Whenever I open Emacs, I feel inspired. Like a craftsman entering his workshop, I feel a realm of possibility open before me. I feel the comfort of an environment that has evolved over time to fit me perfectly—an assortment of packages and key bindings that help me bring ideas to life day after day.</p>
      <p class="Body">These resources will help you as you continue on your Emacs journey:</p>
      <ul class="List-1">
	<li class="BulletA"><em>The Emacs Manual</em> provides excellent, comprehensive instructions. Spend some time with it every morning! Download the PDF and read it on the go: <em><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top">http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top</a></em>.</li>
	<li class="BulletB"><em>The Emacs Reference Card</em> is a handy cheat sheet: <em><a href="http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf">http://www.ic.unicamp.br/~helio/disciplinas/MC102/Emacs_Reference_Card.pdf</a></em>.</li>
	<li class="BulletB"><em>Mastering Emacs</em> by Mickey Petersen is one of the best Emacs resources available. Start with the reading guide: <em><a href="http://www.masteringemacs.org/reading-guide/">http://www.masteringemacs.org/reading-guide/</a></em>.</li>
	<li class="BulletB">For the more visually minded folks, I recommend the hand-drawn “How to Learn Emacs: A Beginner’s Guide to Emacs 24 or Later” by Sacha Chua: <em><a href="http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png">http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.png</a></em>.</li>
	<li class="BulletC">Just press <strong>C-h t</strong> for the built-in tutorial.</li>
      </ul>
      <h2>Summary</h2>
      <p class="BodyFirst">Whew! You’ve covered a lot of ground. You now know about Emacs’s true nature as a Lisp interpreter. Key bindings act as shortcuts to execute elisp functions, and modes are collections of key bindings and functions. You learned how to interact with Emacs on its own terms and mastered buffers, windows, regions, killing, and yanking. Finally, you learned how to easily work with Clojure using CIDER and paredit.</p>
      <p class="Body">With all of this hard-won Emacs knowledge under your belt, it’s time to start learning Clojure in earnest!</p>
      <div class="footnotes">
	<div class="footnote">
	  <p class="Footnote"><a id="footnote-5680-1" class="footnote-anchor" href="#footnote-5680-1-backlink">1</a> <em><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html">http://www.gnu.org/software/emacs/manual/html_node/emacs/Minor-Modes.html</a></em>.</p>
	</div>
      </div>
    
  

