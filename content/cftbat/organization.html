---
title: "Organizing Your Project: A Librarian’s Tale"
kind: chapter
---

  
  
    
      <div class="chapter-number">Chapter 6</div>
      <h1>Organizing Your Project: A Librarian’s Tale</h1>
      <p class="x1st-Para">Within each of us lives a librarian named Melvil, a fantastical creature who delights in the organizational arts. Day and night, Melvil yearns to bring order to your codebase. Fortunately, Clojure provides a suite of tools designed specifically to aid this homunculus in its constant struggle against the forces of chaos.</p>
      <p class="Body">These tools help you organize your code by grouping together related functions and data. They also prevent name collisions so you don’t accidentally overwrite someone else’s code or vice versa. Join me in a tale of suspense and mystery as you learn how to use these tools and solve the heist of a lifetime! By the end of the saga, you’ll understand the following:</p>
      <ul class="List-1">
	<li class="BulletA">What <code>def</code> does</li>
	<li class="BulletB">What namespaces are and how to use them</li>
	<li class="BulletB">The relationship between namespaces and the filesystem</li>
      </ul>
      <p class="Body"></p>
      <ul class="List-1">
	<li class="BulletB">How to use <code>refer</code>, <code>alias</code>, <code>require</code>, <code>use</code>, and <code>ns</code></li>
	<li class="BulletC">How to organize Clojure projects using the filesystem</li>
      </ul>
      <p class="Body">I’ll start with a high-level overview of Clojure’s organizational system, which works much like a library. Melvil quivers with excitement!</p>
      <h2>Your Project as a Library</h2>
      <p class="BodyFirst">Real-world libraries store collections of objects, such as books, magazines, and DVDs. They use addressing systems, so when you’re given an object’s address, you can navigate to the physical space and retrieve the object.</p>
      <p class="Body">Of course, no human being would be expected to know offhand what <span>a book’s or DVD’s address is. That’s why libraries record the association between an object’s title and its address and provide tools for search</span>ing these records. In ye olden times before computers, libraries provided card catalogs, which were cabinets filled with paper cards containing each book’s title, author, “address” (its Dewey decimal or Library of Congress number), and other info. </p>
      <p class="Body"><span>For example, to find </span><em>The Da Vinci Code</em><span>, you would riffle through the title catalog (cards ordered by title) until you found the correct </span>card. On that card you would see the address <em>813.54 </em>(if it’s using the Dewey decimal system), navigate your library to find the shelf where <em>The Da Vinci Code</em> resides, and engage in the literary and/or hate-reading adventure of your lifetime.</p>
      <p class="Body">It’s useful to imagine a similar setup in Clojure. I think of Clojure as <span>storing objects (like data structures and functions) in a vast set of numbered shelves. No human being could know offhand which shelf an object is stored i</span>n. Instead, we give Clojure an identifier that it uses to retrieve the object.</p>
      <p class="Body"><span>For this to be successful, Clojure must maintain the associations </span><span>between our identifiers and shelf addresses. It does this by using </span><em>namespaces</em><span>. </span>Namespaces contain maps between human-friendly <em>symbols</em> and references to shelf addresses, known as <em>vars</em>, much like a card catalog.</p>
      <p class="Body">Technically, namespaces are objects of type <code>clojure.lang.Namespace</code>, and you can interact with them just like you can with Clojure data structures. For example, you can refer to the current namespace with <code>*ns*</code>, and you can get its name with <code>(ns-name *ns*)</code>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">ns-name </span><span class="tok-nv">*ns*</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; user</span>
</code></pre></div></div>

      <p class="Body">When you start the REPL, for example, you’re in the <code>user</code> namespace <span>(as you can see here). The prompt shows the current namespace using </span>something like <code>user=&gt;</code>.</p>
      <p class="Body">The idea of a current namespace implies that you can have more than one, and indeed Clojure allows you to create as many namespaces as you want (although technically, there might be an upper limit to the number of names you can create). In Clojure programs, you are always <em>in</em> a namespace. </p>
      <p class="Body">As for symbols, you’ve been using them this entire time without even realizing it. For example, when you write <code>(map inc [1 2])</code>, both <code>map</code> and <code>inc</code> are symbols. Symbols are data types within Clojure, and I’ll explain them thoroughly in the next chapter. For now, all you need to know is that when you give Clojure a symbol like <code>map</code>, it finds the corresponding var in the current namespace, gets a shelf address, and retrieves an object from that shelf for you—in this case, the function that <code>map</code> refers to. If you want to just use the symbol itself, and not the thing it refers to, you have to quote it. Quoting any Clojure form tells Clojure not to evaluate it but to treat it as data. The next few examples show what happens when you quote a form.</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">➊</span> <span class="tok-nv">inc</span>
<span class="tok-c1">; =&gt; #&lt;core$inc clojure.core$inc@30132014&gt;</span>

<span class="tok-err">➋</span> <span class="tok-ss">'inc</span>
<span class="tok-c1">; =&gt; inc</span>

<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; (2 3)</span>

<span class="tok-err">➍</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; (map inc [1 2])</span>
</code></pre></div></div>

      <p class="Body">When you evaluate <code>inc</code> in the REPL at ➊, it prints out the textual representation of the function that <code>inc</code> refers to. Next, you quote <code>inc</code> at ➋, so the result is the symbol <code>inc</code>. Then, you evaluate a familiar <code>map</code> application at ➌ and get a familiar result. After that, you quote the entire list data structure at ➍, resulting in an unevaluated list that includes the <code>map</code> symbol, the <code>inc</code> symbol, and a vector.</p>
      <p class="Body">Now that you know about Clojure’s organization system, let’s look at how to use it.</p>
      <h2>Storing Objects with def</h2>
      <p class="BodyFirst">The primary tool in Clojure for storing objects is <code>def</code>. Other tools like <code>defn</code> use <code>def</code> under the hood. Here’s an example of def in action:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">great-books</span> <span class="tok-p">[</span><span class="tok-s">"East of Eden"</span> <span class="tok-s">"The Glass Bead Game"</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; #'user/great-books</span>

<span class="tok-nv">great-books</span>
<span class="tok-c1">; =&gt; ["East of Eden" "The Glass Bead Game"]</span>
</code></pre></div></div>

      <p class="Body">This code tells Clojure:</p>
      <ol class="List-1">
	<li class="NumListA">Update the current namespace’s map with the association between <code>great-books</code> and the var.</li>
	<li class="NumListB">Find a free storage shelf.</li>
	<li class="NumListB">Store <code>["East of Eden" "The Glass Bead Game"]</code> on the shelf.</li>
	<li class="NumListB">Write the address of the shelf on the var.</li>
	<li class="NumListC">Return the var (in this case, <code>#'user/great-books</code>).</li>
      </ol>
      <p class="Body"><span>This process is called </span><em>interning</em><span> a var. You can interact with a namespace’s map of symbols-to-interned-vars using </span><code>ns-interns</code><span>. Here’s how you’d get a map of interned vars:</span></p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">ns-interns </span><span class="tok-nv">*ns*</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; {great-books #'user/great-books}</span>
</code></pre></div></div>

      <p class="Body">You can use the <code>get</code> function to get a specific var:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-p">(</span><span class="tok-nb">ns-interns </span><span class="tok-nv">*ns*</span><span class="tok-p">)</span> <span class="tok-ss">'great-books</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #'user/great-books</span>
</code></pre></div></div>

      <p class="Body"><span>By evaluating </span><code>(ns-map *ns*)</code><span class="Default-Paragraph-Font">,</span> <span>you can also get the full map that the namespace uses for looking up a var when given a symbol</span><span class="Default-Paragraph-Font">.</span><span> </span><code>(ns-map *ns*)</code> gives you a very large map that I won’t print here, but try it out! </p>
      <p class="Body"><code>#'user/great-books</code> is the <em>reader form</em> of a var. I’ll explain more about reader forms in Chapter 7. For now, just know that you can use <code>#'</code> to grab hold of the var corresponding to the symbol that follows; <code>#'user/great-books</code> lets you use the var associated with the symbol <code>great-books</code> within the <code>user</code> namespace. We can <code>deref</code> vars to get the objects they point to:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-o">#</span><span class="tok-ss">'user/great-books</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; ["East of Eden" "The Glass Bead Game"]</span>
</code></pre></div></div>

      <p class="Body">This is like telling Clojure, “Get the shelf number from the var, go to that shelf number, grab what’s on it, and give it to me!”</p>
      <p class="Body">But normally, you would just use the symbol:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">great-books</span>
<span class="tok-c1">; =&gt; ["East of Eden" "The Glass Bead Game"]</span>
</code></pre></div></div>

      <p class="Body"><span>This is like telling Clojure, “Retrieve the var associated with great-books</span> and deref that bad Jackson.”</p>
      <p class="Body">So far so good, right? Well, brace yourself, because this idyllic paradise of organization is about to be turned upside down! Call <code>def</code> again with the same symbol:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">great-books</span> <span class="tok-p">[</span><span class="tok-s">"The Power of Bees"</span> <span class="tok-s">"Journey to Upstairs"</span><span class="tok-p">])</span>
<span class="tok-nv">great-books</span>
<span class="tok-c1">; =&gt; ["The Power of Bees" "Journey to Upstairs"]</span>
</code></pre></div></div>

      <img src="/assets/images/cftbat/organization/bee-power.png" class="right" />
      <p class="Body">The var has been updated with the address of the new vector. It’s like you used white-out on the address on a card in the card catalog and then wrote a new address. The result is that you can no longer ask Clojure to find the first vector. This is referred to as a <em>name collision</em>. Chaos! Anarchy!</p>
      <p class="Body"><span>You may have experienced this in other programming languages. </span>JavaScript is notorious for it, and it happens in Ruby as well. It’s a problem because you can unintentionally overwrite your own code, and you also <span>have no guarantee that a third-party library won’t overwrite your code. </span>Melvil recoils in horror! Fortunately, Clojure allows you to create as many namespaces as you like so you can avoid these collisions.</p>
      <h2>Creating and Switching to Namespaces</h2>
      <p class="BodyFirst">Clojure has three tools for creating namespaces: the function <code>create-ns</code>, <span>the function </span><code>in-ns</code><span>, and the macro </span><code>ns</code><span>. </span><span class="Default-Paragraph-Font">Y</span><span>ou’ll mostly use the </span><code>ns</code><span> macro in your </span><span>Clojure files, but I’ll hold off on explaining it for a few pages because it </span>combines many tools, and it’s easier to understand after I discuss each of the other tools.</p>
      <p class="Body"><code>create-ns</code><span> takes a symbol, creates a namespace with that name if it </span>doesn’t exist already, and returns the namespace:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">user=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">create-ns </span><span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #&lt;Namespace cheese.taxonomy&gt;</span>
</code></pre></div></div>

      <p class="Body">You can use the returned namespace as an argument in a function call:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">user=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">ns-name </span><span class="tok-p">(</span><span class="tok-nb">create-ns </span><span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; cheese-taxonomy</span>
</code></pre></div></div>

      <p class="Body">In practice, you’ll probably never use <code>create-ns</code> in your code, because it’s not very useful to create a namespace and not move into it. Using <code>in-ns</code> is more common because it creates the namespace if it doesn’t exist <em>and</em> switches to it, as shown in Listing 6-1.</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">user=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.analysis</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #&lt;Namespace cheese.analysis&gt;</span>
</code></pre></div></div>

      <ol class="List-1">
	<li class="Listing">6-1. Using <span class="LiteralCaption">in-ns</span> to create a namespace and switch to it</li>
      </ol>
      <p class="Body">Notice that your REPL prompt is now <code>cheese.analysis&gt;</code>, indicating that you are indeed in the new namespace you just created. Now when you use <code>def</code>, it will store the named object in the <code>cheese.analysis</code> namespace.</p>
      <p class="Body"><span>But what if you want to use functions and data from other name­spaces? To do that, you can use a </span><em>fully qualified</em><span> symbol. The general form is </span><span class="LiteralItal">namespace</span><code>/</code><span class="LiteralItal">name</span><span>:</span></p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">cheddars</span> <span class="tok-p">[</span><span class="tok-s">"mild"</span> <span class="tok-s">"medium"</span> <span class="tok-s">"strong"</span> <span class="tok-s">"sharp"</span> <span class="tok-s">"extra sharp"</span><span class="tok-p">])</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.analysis</span><span class="tok-p">)</span>

<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">cheddars</span>
<span class="tok-c1">; =&gt; Exception: Unable to resolve symbol: cheddars in this context</span>
</code></pre></div></div>

      <p class="Body"><span>This creates a new namespace, </span><code>cheese.taxonomy</code><span>, defines </span><code>cheddars</code><em> </em><span>in that namespace, and then switches back to the </span><code>cheese.analysis</code><span> namespace. You’ll get an exception if you try to refer to the </span><code>cheese.taxonomy</code><span> namespace’s </span><code>cheddars</code><span> from within </span><code>cheese.analysis</code><span>, but using the fully qualified symbol works:</span></p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">cheese.taxonomy/cheddars</span>
<span class="tok-c1">; =&gt; ["mild" "medium" "strong" "sharp" "extra sharp"]</span>
</code></pre></div></div>

      <p class="Body">Typing these fully qualified symbols can quickly become a nuisance. <span>For instance, say I’m an extremely impatient academic specializing in </span><span>semiotics</span>-au-fromage, or the study of symbols as they relate to cheese.</p>
      <p class="Body">Suddenly, the worst conceivable thing that could possibly happen <span>happens</span>! All across the world, sacred and historically important cheeses have gone missing. Wisconsin’s Standard Cheddar: gone! The Great Cheese Jars of Tutankhamun: stolen! The Cheese of Turin: replaced with a hoax cheese! This threatens to throw the world into total chaos for some reason! Naturally, as a distinguished cheese researcher, I am honor-bound to solve this mystery. Meanwhile, I’m being chased by the Illuminati, the Freemasons, and the Foot Clan!</p>
      <p class="Body">Because I’m an academic, I attempt to solve this mystery the best way I know how—by heading to the library and researching the shit out of it. My trusty assistant, Clojure, accompanies me. As we bustle from namespace to namespace, I shout at Clojure to hand me one thing after another.</p>
      <p class="Body">But Clojure is kind of dumb and has a hard time figuring out what I’m referring to. From within the <code>user</code> namespace, I belt out, “<code>join</code>! Give me <code>join</code>!”—specks of spittle flying from my mouth. “<code>RuntimeException: Unable to resolve symbol: join</code>,” Clojure whines in response. “For the love of brie, just hand me <code>clojure.string/join</code>!” I retort, and Clojure dutifully hands me the function I was looking for.</p>
      <p class="Body">My voice gets hoarse. I need some way to tell Clojure what objects to get me without having to use the fully qualified symbol every. damn. time.</p>
      <p class="Body">Luckily, Clojure provides the <code>refer</code> and <code>alias</code> tools that let me yell at it more succinctly.</p>
      <h3>refer</h3>
      <p class="BodyFirst"><code>refer</code> gives you fine-grained control over how you refer to objects in other namespaces. Fire up a new REPL session and try the following. Keep in mind that it’s okay to play around with namespaces like this in the REPL, but you don’t want your Clojure files to look like this; the proper way to structure your files is covered in <a href="#Anchor">“Real Project Organization” on page <span>133</span></a>.</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">user=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">cheddars</span> <span class="tok-p">[</span><span class="tok-s">"mild"</span> <span class="tok-s">"medium"</span> <span class="tok-s">"strong"</span> <span class="tok-s">"sharp"</span> <span class="tok-s">"extra sharp"</span><span class="tok-p">])</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">bries</span> <span class="tok-p">[</span><span class="tok-s">"Wisconsin"</span> <span class="tok-s">"Somerset"</span> <span class="tok-s">"Brie de Meaux"</span> <span class="tok-s">"Brie de Melun"</span><span class="tok-p">])</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.analysis</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/refer</span> <span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">bries</span>
<span class="tok-c1">; =&gt; ["Wisconsin" "Somerset" "Brie de Meaux" "Brie de Melun"]</span>

<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">cheddars</span>
<span class="tok-c1">; =&gt; ["mild" "medium" "strong" "sharp" "extra sharp"]</span>
</code></pre></div></div>

      <p class="Body">This code creates a <code>cheese.taxonomy</code> namespace and two vectors within it: <code>cheddars</code> and <code>bries</code>. Then it creates and moves to a new namespace called <code>cheese.analysis</code>. Calling <code>refer</code> with a namespace symbol lets you refer to the corresponding namespace’s objects without having to use fully qualified symbols. It does this by updating the current namespace’s symbol/object map. You can see the new entries like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/get</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/ns-map</span> <span class="tok-nv">clojure.core/*ns*</span><span class="tok-p">)</span> <span class="tok-ss">'bries</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #'cheese.taxonomy/bries</span>

<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/get</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/ns-map</span> <span class="tok-nv">clojure.core/*ns*</span><span class="tok-p">)</span> <span class="tok-ss">'cheddars</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #'cheese.taxonomy/cheddars</span>
</code></pre></div></div>

      <p class="Body">It’s as if Clojure</p>
      <ol class="List-1">
	<li class="NumListA">Calls <code>ns-interns</code> on the <code>cheese.taxonomy</code> namespace</li>
	<li class="NumListB">Merges that with the <code>ns-map</code> of the current namespace</li>
	<li class="NumListC">Makes the result the new <code>ns-map</code> of the current namespace</li>
      </ol>
      <p class="Body">When you call <code>refer</code>, you can also pass it the filters <code>:only</code>, <code>:exclude</code>, and <code>:rename</code>. As the names imply, <code>:only</code> and <code>:exclude</code> restrict which symbol/var mappings get merged into the current namespace’s <code>ns-map</code>. <code>:rename</code> lets you use different symbols for the vars being merged in. Here’s what would happen if we had modified the preceding example to use <code>:only</code>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/refer</span> <span class="tok-ss">'cheese.taxonomy</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-ss">'bries</span><span class="tok-p">])</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">bries</span>
<span class="tok-c1">; =&gt; ["Wisconsin" "Somerset" "Brie de Meaux" "Brie de Melun"]</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">cheddars</span> 
<span class="tok-c1">; =&gt; RuntimeException: Unable to resolve symbol: cheddars</span>
</code></pre></div></div>

      <p class="Body">And here’s <code>:exclude</code> in action:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/refer</span> <span class="tok-ss">'cheese.taxonomy</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-ss">'bries</span><span class="tok-p">])</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">bries</span>
<span class="tok-c1">; =&gt; RuntimeException: Unable to resolve symbol: bries</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">cheddars</span> 
<span class="tok-c1">; =&gt; ["mild" "medium" "strong" "sharp" "extra sharp"]</span>
</code></pre></div></div>

      <p class="Body">Lastly, a <code>:rename</code> example:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/refer</span> <span class="tok-ss">'cheese.taxonomy</span> <span class="tok-ss">:rename</span> <span class="tok-p">{</span><span class="tok-ss">'bries</span> <span class="tok-ss">'yummy-bries</span><span class="tok-p">})</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">bries</span>
<span class="tok-c1">; =&gt; RuntimeException: Unable to resolve symbol: bries</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">yummy-bries</span>
<span class="tok-c1">; =&gt; ["Wisconsin" "Somerset" "Brie de Meaux" "Brie de Melun"]</span>
</code></pre></div></div>

      <p class="Body">Notice that in these last examples we have to use the fully qualified names of all the objects in <code>clojure.core</code>, like <code>clojure.core/ns-map</code> and <code>clojure.core/refer</code>. We didn’t have to do that in the <code>user</code> namespace. That’s because the REPL automatically refers <code>clojure.core</code> within the <code>user</code> namespace. You can make your life easier by evaluating <code>(clojure.core/refer-clojure)</code> when you create a new namespace; this will refer the clojure.core namespace, and I’ll be using it from now on. Instead of seeing <code>clojure.core/refer</code> in the examples, you’ll only see <code>refer</code>.</p>
      <p class="Body">Another thing to notice is that you have complete freedom over how you organize your functions and data across namespaces. This lets you sensibly group related functions and data together in the same namespace.</p>
      <p class="Body"><span>Sometimes you may want a function to be available only to other functions </span>within the same namespace. Clojure allows you to define <em>private</em> functions using <code>defn-</code>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.analysis</span><span class="tok-p">)</span>
<span class="tok-c1">;; Notice the dash after "defn"</span>
<span class="tok-p">(</span><span class="tok-kd">defn- </span><span class="tok-nv">private-function</span>
  <span class="tok-s">"Just an example function that does nothing"</span>
  <span class="tok-p">[])</span>
</code></pre></div></div>

      <p class="Body">If you try to call this function from another namespace or refer it, Clojure will throw an exception. You can see this when you evaluate the code at ➊ and ➋:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/refer-clojure</span><span class="tok-p">)</span>
<span class="tok-err">➊</span> <span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">cheese.analysis/private-function</span><span class="tok-p">)</span>
<span class="tok-err">➋</span> <span class="tok-nv">cheese.taxonomy=&gt;</span> <span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'cheese.analysis</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-ss">'private-function</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">As you can see, even if you explicitly <code>refer</code> the function, you can’t use the function from another namespace, because you made it private. (If you want to be tricky, you can still access the private var using the arcane syntax <code>@#'some/private-var</code>, but you’ll rarely want to do that.)</p>
      <h3>alias</h3>
      <p class="BodyFirst">Compared to <code>refer</code>, <code>alias</code> is relatively simple. All it does is let you shorten a namespace name for using fully qualified symbols:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-p">(</span><span class="tok-nf">clojure.core/alias</span> <span class="tok-ss">'taxonomy</span> <span class="tok-ss">'cheese.taxonomy</span><span class="tok-p">)</span>
<span class="tok-nv">cheese.analysis=&gt;</span> <span class="tok-nv">taxonomy/bries</span>
<span class="tok-c1">; =&gt; ["Wisconsin" "Somerset" "Brie de Meaux" "Brie de Melun"]</span>
</code></pre></div></div>

      <p class="Body">This code lets us use call symbols from the <code>cheese.taxonomy</code> namespace with the shorter alias <code>taxonomy</code>. </p>
      <p class="Body"><code>refer</code> and <code>alias</code> are your two basic tools for referring to objects outside your current namespace! They’re great aids to REPL development.</p>
      <p class="Body"><span>However, it’s unlikely that you’d create your entire program in the </span>REPL. In the next section, I’ll cover everything you need to know to organize a real project with source code living on the filesystem.</p>
      <h2><a id="Anchor"></a>Real Project Organization</h2>
      <p class="BodyFirst">Now that I’ve covered the building blocks of Clojure’s organization system, I’ll show you how to use them in real projects. I’ll discuss the relationship between file paths and namespace names, explain how to load a file with <code>require</code> and <code>use</code>, and show how to use <code>ns</code> to set up a namespace.</p>
      <h3><a id="Anchor-3"></a>The Relationship Between File Paths and Namespace Names</h3>
      <p class="BodyFirst">To kill two birds with one stone (or feed two birds with one seed, depending on how much of a hippie you are), I’ll cover more on namespaces while we work on catching the pesky international cheese thief by mapping the locations of his heists. Run the following:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">lein</span> <span class="tok-k">new </span><span class="tok-nv">app</span> <span class="tok-nv">the-divine-cheese-code</span>
</code></pre></div></div>

      <p class="Body">This should create a directory structure that looks like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">|</span> <span class="tok-nv">.gitignore</span>
<span class="tok-err">|</span> <span class="tok-nv">doc</span>
<span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">intro.md</span>
<span class="tok-err">|</span> <span class="tok-nv">project.clj</span>
<span class="tok-err">|</span> <span class="tok-nv">README.md</span>
<span class="tok-err">|</span> <span class="tok-nv">resources</span>
<span class="tok-err">|</span> <span class="tok-nv">src</span>
<span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">the_divine_cheese_code</span>
<span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core.clj</span>
<span class="tok-err">|</span> <span class="tok-nv">test</span>
<span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">the_divine_cheese_code</span>
<span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core_test.clj</span>
</code></pre></div></div>

      <p class="Body">Now, open <em>src/the_divine_cheese_code/core.clj</em>. You should see this on the first line:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:gen-class</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="Body"><code>ns</code> is the primary way to create and manage namespaces within Clojure. I’ll explain it in full shortly. For now, though, just know that this line is very similar to the <code>in-ns</code> function we used in Listing 6-1. It creates a namespace if it doesn’t exist and then switches to it. I also cover <code>(:gen-class)</code> in more detail in Chapter 12.</p>
      <p class="Body">The name of the namespace is <code>the-divine-cheese-code.core</code>. In Clojure, there’s a one-to-one mapping between a namespace name and the path of the file where the namespace is declared, according to the following conventions:</p>
      <ul class="List-1">
	<li class="BulletA">When you create a directory with <code>lein</code> (as you did here), the source code’s root is <em>src</em> by default. </li>
	<li class="BulletB">Dashes in namespace names correspond to underscores in the file­system. So <code>the-divine-cheese-code</code> is mapped to <em>the_divine_cheese_code</em> on the filesystem.</li>
	<li class="BulletB">The component preceding a period (<code>.</code>) in a namespace name corresponds to a directory. For example, since <code>the-divine-cheese-code.core</code> is the namespace name, <em>the_divine_cheese_code</em> is a directory.</li>
	<li class="BulletC">The final component of a namespace corresponds to a file with the <em>.clj</em> extension; <code>core</code> is mapped to <em>core.clj</em>.</li>
      </ul>
      <p class="Body"><span>Your project will have one more namespace, </span><code>the-divine-cheese-code.visualization.svg</code>. Go ahead and create the file for it now:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-nv">mkdir</span> <span class="tok-nv">src/the_divine_cheese_code/visualization</span>
<span class="tok-nv">touch</span> <span class="tok-nv">src/the_divine_cheese_code/visualization/svg.clj</span>
</code></pre></div></div>

      <p class="Body">Notice that the filesystem path follows these conventions. With the relationship between namespaces and the filesystem down, let’s look at <code>require</code> and <code>use</code>.</p>
      <h3>Requiring and Using Namespaces</h3>
      <p class="BodyFirst">The code in the <code>the-divine-cheese-code.core</code> namespace will use the functions in the namespace <code>the-divine-cheese-code.visualization.svg</code> to create SVG markup. To use <code>svg</code>’s functions, <code>core</code> will have to <em>require</em> it. But first, let’s add some code to <em>svg.clj</em>. Make it look like this (you’ll add more later):</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">latlng-&gt;point</span>
  <span class="tok-s">"Convert lat/lng map to comma-separated string"</span> 
  <span class="tok-p">[</span><span class="tok-nv">latlng</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:lat</span> <span class="tok-nv">latlng</span><span class="tok-p">)</span> <span class="tok-s">","</span> <span class="tok-p">(</span><span class="tok-ss">:lng</span> <span class="tok-nv">latlng</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">points</span>
  <span class="tok-p">[</span><span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">clojure.string/join</span> <span class="tok-s">" "</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">latlng-&gt;point</span> <span class="tok-nv">locations</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body">This defines two functions, <code>latlng-&gt;point</code> and <code>points</code>, which you’ll use to convert a seq of latitude/longitude coordinates into a string of points. <span>To use this code from the </span><em>core.clj</em><span> file, you have to </span><code>require</code><span> it. </span><code>require</code><span> </span>takes a symbol designating a namespace and ensures that the namespace exists and <span>is ready to be used; in this case, when you call </span><code>(require 'the-divine-cheese-code.visualization.svg)</code>, Clojure reads and evaluates the corresponding file. By evaluating the file, it creates the <code>the-divine-cheese-code.visualization.svg</code> namespace and defines the functions <code>latlng-&gt;point</code> and <code>points</code> within that namespace. Even though the file <em>svg.clj</em> is in your project’s directory, Clojure doesn’t automatically evaluate it when it runs your project; you have to explicitly tell Clojure that you want to use it.</p>
      <p class="Body">After requiring the namespace, you can <em>refer</em> it so that you don’t have to use fully qualified names to reference the functions. Go ahead and require <code>the-divine-cheese-code.visualization.svg</code><span> and add the </span><code>heists</code><span> seq to make </span><em>core.clj</em> match the listing:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-c1">;; Ensure that the SVG code is evaluated</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-c1">;; Refer the namespace so that you don't have to use the </span>
<span class="tok-c1">;; fully qualified name to reference svg functions</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">heists</span> <span class="tok-p">[{</span><span class="tok-ss">:location</span> <span class="tok-s">"Cologne, Germany"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"Archbishop Hildebold's Cheese Pretzel"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">50.95</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">6.97</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Zurich, Switzerland"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Standard Emmental"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">47.37</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">8.55</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Marseille, France"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"Le Fromage de Cosquer"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">43.30</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">5.37</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Zurich, Switzerland"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Lesser Emmental"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">47.37</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">8.55</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Vatican City"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Cheese of Turin"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">41.90</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">12.45</span><span class="tok-p">}])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">-main</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">args</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-p">(</span><span class="tok-nf">points</span> <span class="tok-nv">heists</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body">Now you have a seq of heist locations to work with and you can use functions from the <code>visualization.svg</code> namespace. The <code>main</code> function simply applies the <code>points</code> function to <code>heists</code>. If you run the project with <code>lein run</code>, you should see this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-mf">50.95</span>,<span class="tok-mf">6.97</span> <span class="tok-mf">47.37</span>,<span class="tok-mf">8.55</span> <span class="tok-mf">43.3</span>,<span class="tok-mf">5.37</span> <span class="tok-mf">47.37</span>,<span class="tok-mf">8.55</span> <span class="tok-mf">41.9</span>,<span class="tok-mf">12.45</span>
</code></pre></div></div>

      <p class="Body">Hooray! You’re one step closer to catching that purloiner of the fermented curd! Using <code>require</code> successfully loaded <code>the-divine-cheese-code.visualization.svg</code> for use.</p>
      <p class="Body">The details of <code>require</code> are actually a bit complicated, but for practical purposes you can think of <code>require</code> as telling Clojure the following:</p>
      <ol class="List-1">
	<li class="NumListA">Do nothing if you’ve already called <code>require</code> with this symbol (<code>the-divine-cheese-code.visualization.svg</code>). </li>
	<li class="NumListC">Otherwise, find the file that corresponds to this symbol using the rules described in <a href="#Anchor-3">“The Relationship Between File Paths and Namespace Names” on page <span>133</span></a>. In this case, Clojure finds <code>src/the_divine_cheese_code/visualization/svg.clj</code>.</li>
      </ol>
      <p class="Body">Read and evaluate the contents of that file. Clojure expects the file to declare a namespace corresponding to its path (which ours does).</p>
      <p class="Body"><code>require</code> also lets you alias a namespace when you require it, using <code>:as</code> or <code>alias</code>. This:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-nv">svg</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">alias</span> <span class="tok-ss">'svg</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">You can now use the aliased namespace:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">svg/points</span> <span class="tok-nv">heists</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "50.95,6.97 47.37,8.55 43.3,5.37 47.37,8.55 41.9,12.45"</span>
</code></pre></div></div>

      <p class="Body">Clojure provides another shortcut. Instead of calling <code>require</code> and <code>refer</code> separately, the function <code>use</code> does both. It’s frowned upon to use <code>use</code> in production code, but it’s handy when you’re experimenting in the REPL and you want to quickly get your hands on some functions. For example, this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">You can alias a namespace with <code>use</code> just like you can with <code>require</code>. This:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">alias</span> <span class="tok-ss">'svg</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="BodyFirst"><span>is equivalent to the code in Listing 6-2, which also shows aliased namespaces </span>being used in function calls.</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-nv">svg</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">svg/points</span> <span class="tok-nv">points</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">svg/latlng-&gt;point</span> <span class="tok-nv">latlng-&gt;point</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; true</span>
</code></pre></div></div>

      <ol class="List-1">
	<li class="Listing">6-2. Sometimes it’s handy to both use and alias a namespace.</li>
      </ol>
      <p class="Body">It may seem redundant to alias a namespace with <code>use</code> here because <code>use</code> already refers the namespace (which lets you simply call <code>points</code> instead of <code>svg/points</code>). In certain situations, though, it’s handy because <code>use</code> takes the same options as <code>refer</code> (<code>:only</code>, <code>:exclude</code>, <code>:as</code>, and <code>:rename</code>). You might want to alias a namespace with <code>use</code> when you’ve skipped referring a symbol. You could use this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-ss">'points</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">Or you could use the <code>use</code> form in Listing 6-3 (which also includes <span>examples</span> of how you can call functions).</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-nv">svg</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-nv">points</span><span class="tok-p">]])</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-ss">'points</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">svg/points</span> <span class="tok-nv">points</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; true</span>

<span class="tok-c1">;; We can use the alias to reach latlng-&gt;point</span>
<span class="tok-nv">svg/latlng-&gt;point</span>
<span class="tok-c1">; This doesn't throw an exception</span>

<span class="tok-c1">;; But we can't use the bare name</span>
<span class="tok-nv">latlng-&gt;point</span>
<span class="tok-c1">; This does throw an exception!</span>
</code></pre></div></div>

      <ol class="List-1">
	<li class="Listing"><span>Aliasing a namespace after you use it lets you refer to symbols that you excluded.</span></li>
      </ol>
      <p class="Body"><span>If you try Listing 6-3 in a REPL and </span><code>latlng-&gt;point</code><span> doesn’t throw an </span>exception, it’s because you referred <code>latlng-&gt;point</code> in Listing 6-2. You’ll need to restart your REPL session for the code to behave as shown in Listing 6-3.</p>
      <p class="Body">The takeaway here is that <code>require</code> and <code>use</code> load files and optionally <code>alias</code> <span>or </span><code>refer</code><span> their namespaces. As you write Clojure programs and read code written by others, you might encounter even more ways of writing </span><code>require</code><span> and </span><code>use</code><span>, at which point it’ll make sense to read Clojure’s API docs (</span><em><a href="http://clojure.org/libs/">http://clojure.org/libs/</a></em><span>) to understand what’s going on. However, what you’ve learned so far about </span><code>require</code><span> and </span><code>use</code><span> should cover 95.3 percent of your needs.</span></p>
      <h3>The ns Macro</h3>
      <p class="BodyFirst"><span>Now it’s time to look at the </span><code>ns</code><span> macro. The tools covered so far—</span><code>in-ns</code><span>, </span><code>refer</code><span>, </span><code>alias</code><span>, </span><code>require</code><span>, and </span><code>use</code><span>—are most often used when you’re playing in the </span>REPL. In your source code files, you’ll typically use the <code>ns</code> macro because it allows you to use the tools described so far succinctly and provides other useful functionality. In this section, you’ll learn about how one <code>ns</code> call can incorporate <code>require</code>, <code>use</code>, <code>in-ns</code>, <code>alias</code>, and <code>refer</code>.</p>
      <p class="Body">One useful task <code>ns</code> does is refer the <code>clojure.core</code> namespace by default. That’s why you can call <code>println</code> from within <code>the-divine-cheese-code.core</code> without using the fully qualified name, <code>clojure.core/println</code>.</p>
      <p class="Body">You can control what gets referred from <code>clojure-core</code> with <code>:refer-clojure</code>, which takes the same options as <code>refer</code>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:refer-clojure</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-nv">println</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <p class="Body"><span>If you called this at the beginning of </span><em>divine_cheese_code.core.clj</em><span>, it would break your code, forcing you to use </span><code>clojure.core/println</code><span> </span>within the <code>-main</code> function.</p>
      <p class="Body">Within <code>ns</code>, the form <code>(:refer-clojure)</code> is called a <em>reference</em>. This might look weird to you. Is this reference a function call? A macro? What is it? You’ll learn more about the underlying machinery in Chapter 7. For now, you just <span>need to understand how each reference maps to function calls. For example, </span>the preceding code is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'clojure.core</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-ss">'println</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">There are six possible kinds of references within <code>ns</code>:</p>
      <ul class="List-1">
	<li class="BulletA"><code>(:refer-clojure)</code></li>
	<li class="BulletB"><code>(:require)</code></li>
	<li class="BulletB"><code>(:use)</code></li>
	<li class="BulletB"><code>(:import)</code></li>
	<li class="BulletB"><code>(:load)</code></li>
	<li class="BulletC"><code>(:gen-class)</code></li>
      </ul>
      <p class="Body"><code>(:import)</code><span> and </span><code>(:gen-class)</code><span> are covered in Chapter 12. I won’t cover </span><code>(:load)</code><span> because it is seldom used.</span></p>
      <p class="Body"><code>(:require)</code> works a lot like the <code>require</code> function. For example, this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-nv">the-divine-cheese-code.visualization.svg</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body"><span>Notice that in the </span><code>ns</code><span> form (unlike the </span><code>in-ns</code><span> function call), you don’t have to quote your symbol with </span><code>'</code><span>. You never have to quote symbols within </span><code>ns</code><span>.</span></p>
      <p class="Body">You can also <code>alias</code> a library that you <code>require</code> within <code>ns</code>, just like when you call the function. This:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-nv">svg</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-p">[</span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-ss">'svg</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">You can require multiple libraries in a <code>(:require)</code> reference as follows. This:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-nv">svg</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">clojure.java.browse</span> <span class="tok-ss">:as</span> <span class="tok-nv">browse</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-p">[</span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:as</span> <span class="tok-ss">'svg</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-p">[</span><span class="tok-ss">'clojure.java.browse</span> <span class="tok-ss">:as</span> <span class="tok-ss">'browse</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">However, one difference between the <code>(:require)</code> reference and the <code>require</code> function is that the reference also allows you to refer names. This:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">points</span><span class="tok-p">]]))</span>
</code></pre></div></div>

      <p class="BodyFirst">is equivalent to this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:only</span> <span class="tok-p">[</span><span class="tok-ss">'points</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">You can also refer all symbols (notice the <code>:all</code> keyword):</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:refer</span> <span class="tok-ss">:all</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <p class="BodyFirst">which is the same as doing this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nb">refer </span><span class="tok-ss">'the-divine-cheese-code.visualization.svg</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">This is the preferred way to require code, alias namespaces, and refer symbols. It’s recommended that you not use <code>(:use)</code>, but since it’s likely that <span>you’ll come across it, it’s good to know how it works. You know the drill. This:</span></p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:use</span> <span class="tok-nv">clojure.java.browse</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="BodyFirst">does this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">'clojure.java.browse</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="BodyFirst">whereas this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:use</span> <span class="tok-p">[</span><span class="tok-nv">clojure.java</span> <span class="tok-nv">browse</span> <span class="tok-nv">io</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <p class="BodyFirst">does this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">in-ns </span><span class="tok-ss">'the-divine-cheese-code.core</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">'clojure.java.browse</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">'clojure.java.io</span><span class="tok-p">)</span>
</code></pre></div></div>

      <p class="Body">Notice that when you follow <code>:use</code> with a vector, it takes the first symbol as the <em>base</em> and then calls <code>use</code> with each symbol that follows.</p>
      <p class="Body">Oh my god, that’s it! Now you can use <code>ns</code> like a pro! And you’re going to need to, dammit, because that <em>voleur des fromages</em> (as they probably say in French) is still running amok! Remember him/her?!</p>
      <h2>To Catch a Burglar</h2>
      <p class="BodyFirst"><span>We can’t allow this plunderer of parmesan to make off with any more cheese! </span>It’s time to finish drawing lines based on the coordinates of the heists! That will surely reveal something!</p>
      <p class="Body">Using the latitude coordinates for each heist, you’ll connect the dots in an SVG image. But if you draw lines using the given coordinates, the result <span>won’t look right for two reasons. First, latitude coordinates ascend from </span>south to north, whereas SVG <span class="Default-Paragraph-Font">y</span>-coordinates ascend from top to <span>bottom</span>. In other words, you need to flip the coordinates or the drawing will be upside down.</p>
      <p class="Body">Second, the drawing will be very small. To fix that, you’ll zoom in on it by translating and scaling it. It’s like turning a drawing that looks like Figure 6-1a into Figure 6-1b.</p>
      <div class="figure">
        <img src="/assets/images/cftbat/organization/svg-before.png" />
        <img src="/assets/images/cftbat/organization/svg-after.png" />
      </div>
      
	<div class="caption">Figure 6-1: Flipping, translating, and scaling latitude coordinates to make an SVG image.</div>
      
      <p class="Body"><span>Honestly, this is all completely arbitrary and it’s no longer directly related </span>to code organization, but it’s fun and I think you’ll have a good time going through the code! Make your <em>svg.clj</em> file match Listing 6-4:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.string</span> <span class="tok-ss">:as</span> <span class="tok-nv">s</span><span class="tok-p">])</span>
  <span class="tok-p">(</span><span class="tok-ss">:refer-clojure</span> <span class="tok-ss">:exclude</span> <span class="tok-p">[</span><span class="tok-nb">min </span><span class="tok-nv">max</span><span class="tok-p">]))</span>

<span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">comparator-over-maps</span>
  <span class="tok-p">[</span><span class="tok-nv">comparison-fn</span> <span class="tok-nv">ks</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">maps</span><span class="tok-p">]</span>
<span class="tok-err">➋</span>     <span class="tok-p">(</span><span class="tok-nb">zipmap </span><span class="tok-nv">ks</span>
<span class="tok-err">➌</span>             <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">k</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">apply </span><span class="tok-nv">comparison-fn</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">k</span> <span class="tok-nv">maps</span><span class="tok-p">)))</span>
                 <span class="tok-nv">ks</span><span class="tok-p">))))</span>

<span class="tok-err">➍</span> <span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">min </span><span class="tok-p">(</span><span class="tok-nf">comparator-over-maps</span> <span class="tok-nv">clojure.core/min</span> <span class="tok-p">[</span><span class="tok-ss">:lat</span> <span class="tok-ss">:lng</span><span class="tok-p">]))</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">max </span><span class="tok-p">(</span><span class="tok-nf">comparator-over-maps</span> <span class="tok-nv">clojure.core/max</span> <span class="tok-p">[</span><span class="tok-ss">:lat</span> <span class="tok-ss">:lng</span><span class="tok-p">]))</span>
</code></pre></div></div>

      <ol class="List-1">
	<li class="Listing">6-3. Constructing map comparison functions</li>
      </ol>
      <p class="Body">You define the <code>comparator-over-maps</code> function at ➊. This is probably the trickiest bit, so bear with me. <code>comparator-over-maps</code> is a function that returns a function. The returned function compares the values for the keys provided by the <code>ks</code> parameter using the supplied comparison function, <code>comparison-fn</code>.</p>
      <p class="Body">You use <code>comparator-over-maps</code> to construct the <code>min</code> and <code>max</code> functions ➍, which you’ll use to find the top-left and bottom-right corners of our drawing. Here’s <code>min</code> in action:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">min </span><span class="tok-p">[{</span><span class="tok-ss">:a</span> <span class="tok-mi">1</span> <span class="tok-ss">:b</span> <span class="tok-mi">3</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-mi">5</span> <span class="tok-ss">:b</span> <span class="tok-mi">0</span><span class="tok-p">}])</span>
<span class="tok-c1">; =&gt; {:a 1 :b 0}</span>
</code></pre></div></div>

      <p class="Body">When you call <code>min</code>, it calls <code>zipmap</code> , which takes two arguments, both seqs, and returns a new map. The elements of the first seq become the keys, and the elements of the second seq become the values:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">zipmap </span><span class="tok-p">[</span><span class="tok-ss">:a</span> <span class="tok-ss">:b</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
<span class="tok-c1">; =&gt; {:a 1 :b 2}</span>
</code></pre></div></div>

      <p class="Body">At , the first argument to <code>zipmap</code> is <code>ks</code>, so the elements of <code>ks</code> will be the keys of the returned map. The second argument is the result of the map call at ➌. That map call actually performs the comparison.</p>
      <p class="Body"><span>Finally, at </span>➍<span> you use </span><code>comparator-over-maps</code><span> to create the comparison functions. If you think of the drawing as being inscribed in a rectangle, </span><code>min</code><span> is the corner of the rectangle closest to (0, 0) and </span><code>max</code><span> is the corner farthest from it.</span></p>
      <p class="Body">Here’s the next part of the code:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"> <span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">translate-to-00</span>
  <span class="tok-p">[</span><span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">mincoords</span> <span class="tok-p">(</span><span class="tok-nb">min </span><span class="tok-nv">locations</span><span class="tok-p">)]</span>
    <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">merge-with - </span><span class="tok-nv">%</span> <span class="tok-nv">mincoords</span><span class="tok-p">)</span> <span class="tok-nv">locations</span><span class="tok-p">)))</span>

 <span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">scale</span>
  <span class="tok-p">[</span><span class="tok-nv">width</span> <span class="tok-nv">height</span> <span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">maxcoords</span> <span class="tok-p">(</span><span class="tok-nb">max </span><span class="tok-nv">locations</span><span class="tok-p">)</span>
        <span class="tok-nv">ratio</span> <span class="tok-p">{</span><span class="tok-ss">:lat</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-nv">height</span> <span class="tok-p">(</span><span class="tok-ss">:lat</span> <span class="tok-nv">maxcoords</span><span class="tok-p">))</span>
               <span class="tok-ss">:lng</span> <span class="tok-p">(</span><span class="tok-nb">/ </span><span class="tok-nv">width</span> <span class="tok-p">(</span><span class="tok-ss">:lng</span> <span class="tok-nv">maxcoords</span><span class="tok-p">))}]</span>
    <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">merge-with * </span><span class="tok-nv">%</span> <span class="tok-nv">ratio</span><span class="tok-p">)</span> <span class="tok-nv">locations</span><span class="tok-p">)))</span>
</code></pre></div></div>

      <p class="Body"><code>translate-to-00</code>, defined at , works by finding the <code>min</code> of our locations and subtracting that value from each location. It uses <code>merge-with</code>, which works like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">merge-with - </span><span class="tok-p">{</span><span class="tok-ss">:lat</span> <span class="tok-mi">50</span> <span class="tok-ss">:lng</span> <span class="tok-mi">10</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:lat</span> <span class="tok-mi">5</span> <span class="tok-ss">:lng</span> <span class="tok-mi">5</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; {:lat 45 :lng 5}</span>
</code></pre></div></div>

      <p class="Body">Then we define the function <code>scale</code> at , which multiplies each point by the ratio between the maximum latitude and longitude and the desired height and width.</p>
      <p class="Body">Here’s the rest of the code for <em>svg.clj</em>:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">latlng-&gt;point</span>
  <span class="tok-s">"Convert lat/lng map to comma-separated string"</span> 
  <span class="tok-p">[</span><span class="tok-nv">latlng</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:lat</span> <span class="tok-nv">latlng</span><span class="tok-p">)</span> <span class="tok-s">","</span> <span class="tok-p">(</span><span class="tok-ss">:lng</span> <span class="tok-nv">latlng</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">points</span>
  <span class="tok-s">"Given a seq of lat/lng maps, return string of points joined by space"</span>
  <span class="tok-p">[</span><span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">s/join</span> <span class="tok-s">" "</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">latlng-&gt;point</span> <span class="tok-nv">locations</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">line</span>
  <span class="tok-p">[</span><span class="tok-nv">points</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"&lt;polyline points=\""</span> <span class="tok-nv">points</span> <span class="tok-s">"\" /&gt;"</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">transform</span>
  <span class="tok-s">"Just chains other functions"</span>
  <span class="tok-p">[</span><span class="tok-nv">width</span> <span class="tok-nv">height</span> <span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">locations</span>
       <span class="tok-nv">translate-to-00</span>
       <span class="tok-p">(</span><span class="tok-nf">scale</span> <span class="tok-nv">width</span> <span class="tok-nv">height</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">xml</span>
  <span class="tok-s">&quot;svg &#39;template&#39;, which also flips the coordinate system&quot;</span>
  <span class="tok-p">[</span><span class="tok-nv">width</span> <span class="tok-nv">height</span> <span class="tok-nv">locations</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;&lt;svg height=\&quot;&quot;</span> <span class="tok-nv">height</span> <span class="tok-s">&quot;\&quot; width=\&quot;&quot;</span> <span class="tok-nv">width</span> <span class="tok-s">&quot;\&quot;&gt;&quot;</span>
       <span class="tok-c1">;; These two &lt;g&gt; tags change the coordinate system so that</span>
       <span class="tok-c1">;; 0,0 is in the lower-left corner, instead of SVG&#39;s default</span>
       <span class="tok-c1">;; upper-left corner</span>
       <span class="tok-s">&quot;&lt;g transform=\&quot;translate(0,&quot;</span> <span class="tok-nv">height</span> <span class="tok-s">&quot;)\&quot;&gt;&quot;</span>
       <span class="tok-s">&quot;&lt;g transform=\&quot;rotate(-90)\&quot;&gt;&quot;</span>
       <span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">transform</span> <span class="tok-nv">width</span> <span class="tok-nv">height</span> <span class="tok-nv">locations</span><span class="tok-p">)</span>
           <span class="tok-nv">points</span>
           <span class="tok-nv">line</span><span class="tok-p">)</span>
       <span class="tok-s">&quot;&lt;/g&gt;&lt;/g&gt;&quot;</span>
       <span class="tok-s">&quot;&lt;/svg&gt;&quot;</span><span class="tok-p">))</span></code></pre></div></div>

      <p class="Body"><span>The functions here are pretty straightforward. They just take </span><code>{:lat x :lng y}</code><span> maps and transform them so that an SVG can be created. </span><code>latlng-&gt;point</code><span> returns a string that can be used to define a point in SVG markup. </span><code>points</code><span> converts a seq of </span><code>lat</code><span>/</span><code>lng</code><span> maps into a space-separated </span>string of points. <code>line</code> returns the SVG markup for a line that connects all given space-separated strings of points. <code>transform</code> takes a seq of locations, <span>translates them so they start at the point (0, 0), and scales them to the given width and height. Finally, </span><code>xml</code><span> produces the markup for displaying the given locations using SVG.</span></p>
      <p class="Body">With <em>svg.clj</em> all coded up, now make <em>core.clj</em> look like this:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">the-divine-cheese-code.core</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">clojure.java.browse</span> <span class="tok-ss">:as</span> <span class="tok-nv">browse</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">the-divine-cheese-code.visualization.svg</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">xml</span><span class="tok-p">]])</span>
  <span class="tok-p">(</span><span class="tok-ss">:gen-class</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">heists</span> <span class="tok-p">[{</span><span class="tok-ss">:location</span> <span class="tok-s">"Cologne, Germany"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"Archbishop Hildebold's Cheese Pretzel"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">50.95</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">6.97</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Zurich, Switzerland"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Standard Emmental"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">47.37</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">8.55</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Marseille, France"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"Le Fromage de Cosquer"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">43.30</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">5.37</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Zurich, Switzerland"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Lesser Emmental"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">47.37</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">8.55</span><span class="tok-p">}</span>
             <span class="tok-p">{</span><span class="tok-ss">:location</span> <span class="tok-s">"Vatican City"</span>
              <span class="tok-ss">:cheese-name</span> <span class="tok-s">"The Cheese of Turin"</span>
              <span class="tok-ss">:lat</span> <span class="tok-mf">41.90</span>
              <span class="tok-ss">:lng</span> <span class="tok-mf">12.45</span><span class="tok-p">}])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">url</span>
  <span class="tok-p">[</span><span class="tok-nv">filename</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"file:///"</span>
       <span class="tok-p">(</span><span class="tok-nf">System/getProperty</span> <span class="tok-s">"user.dir"</span><span class="tok-p">)</span>
       <span class="tok-s">"/"</span>
       <span class="tok-nv">filename</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">template</span>
  <span class="tok-p">[</span><span class="tok-nv">contents</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"&lt;style&gt;polyline { fill:none; stroke:#5881d8; stroke-width:3}&lt;/style&gt;"</span>
       <span class="tok-nv">contents</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">-main</span>
  <span class="tok-p">[</span><span class="tok-o">&amp;</span> <span class="tok-nv">args</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">filename</span> <span class="tok-s">"map.html"</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">heists</span>
         <span class="tok-p">(</span><span class="tok-nf">xml</span> <span class="tok-mi">50</span> <span class="tok-mi">100</span><span class="tok-p">)</span>
         <span class="tok-nv">template</span>
         <span class="tok-p">(</span><span class="tok-nf">spit</span> <span class="tok-nv">filename</span><span class="tok-p">))</span>
    <span class="tok-p">(</span><span class="tok-nf">browse/browse-url</span> <span class="tok-p">(</span><span class="tok-nf">url</span> <span class="tok-nv">filename</span><span class="tok-p">))))</span>
</code></pre></div></div>

      <p class="Body">Nothing too complicated is going on here. Within <code>-main</code> you build up the drawing using the <code>xml</code> and <code>template</code> functions, write the drawing to a file with <code>spit</code>, and then open it with <code>browse/browse-url</code>. You should try that now! Run <code>lein run</code> and you’ll see something that looks like Figure 6-2.</p>
      <p><style>polyline { fill:none; stroke:#5881d8; stroke-width:3}</style><svg height="100" width="50"><g transform="translate(0,100)"><g transform="scale(1,-1)"><polyline points="11.299435028248586,100.0 22.457627118644073,60.441988950276205 0.0,15.469613259668485 22.457627118644073,60.441988950276205 50.0,0.0"></polyline></g></g></svg></p>
      
	<div class="caption">Figure 6-2: The final SVG of the heist pattern!</div>
      
      <p class="Body">Wait a minute . . . that looks a lot like . . . that looks a lot like a lambda. Clojure’s logo is a lambda . . . oh my god! Clojure, it was you this whole time!</p>
      <h2>Summary</h2>
      <p class="BodyFirst">You learned a lot in this chapter. At this point, you should have all the tools you need to start organizing your projects. You now know that namespaces organize maps between symbols and vars,<em> </em>and that vars are references to Clojure objects (data structures, functions, and so on). <code>def</code> stores an object and updates the current namespace with a map between a symbol and a var that points to the object. You can create private functions with <code>defn-</code>.</p>
      <p class="Body">Clojure lets you create namespaces with <code>create-ns</code>, but often it’s more useful to use <code>in-ns</code>, which switches to the namespace as well. You’ll probably <span>only use these functions in the REPL. When you’re in the REPL, you’re </span>always <em>in</em> the current namespace. When you’re defining namespaces in a file rather than the REPL, you should use the <code>ns</code> macro, and there’s a one-to-one relationship between a namespace and its path on the filesystem.</p>
      <p class="Body">You can refer to objects in other namespaces by using the fully qualified name, like <code>cheese.taxonomy/cheddars</code>. <code>refer</code> lets you use names from other namespaces without having to fully qualify them, and <code>alias</code> lets you use a <span>shorter name for a namespace when you’re writing out a fully qualified name.</span></p>
      <p class="Body"><code>require</code> and <code>use</code> ensure that a namespace exists and is ready to be used, and optionally let you <code>refer</code> and <code>alias</code> the corresponding namespaces. You <span>should use </span><code>ns</code><span> to call </span><code>require</code><span> and </span><code>use</code><span> in your source files. </span><em><a href="https://gist.github.com/ghoseb/287710/">https://gist.github.com/ghoseb/287710/</a></em> is a great reference for all the vagaries of using <code>ns</code>.</p>
      <p class="Body">Lastly and most importantly, it ain’t easy being cheesy.</p>
      <img src="/assets/images/cftbat/organization/cheese.png" class="figure" />
    
  

