---
title: "Creating and Extending Abstractions with Multimethods, Protocols, and Records"
kind: chapter
---

  
  
    
      <div class="chapter-number">Chapter 13</div>
      <h1>Creating and Extending Abstractions with Multimethods, Protocols, and Records</h1>
      <p class="x1st-Para">Take a minute to contemplate how great it is to be one of Mother Nature’s top-of-the-line products: a human. As a human, you get to gossip on social media, play Dungeons and Dragons, and wear hats. Perhaps more important, you get to think and communicate in terms of abstractions.</p>
      <p class="Body"><span>The ability to think in terms of abstractions is truly one of the best human features. It lets you circumvent your cognitive limits by tying together disparate details into a neat conceptual package that you can hold in your working memory. Instead of having to think the clunky thought “squeezable honking red ball nose adornment,” you only need the concept “clown nose.” </span></p>
      <p class="Body">In Clojure, an <em>abstraction</em> is a collection of operations, and <em>data types</em> implement abstractions. For example, the seq abstraction consists of operations like <code>first</code> and <code>rest</code>, and the vector data type is an implementation of that abstraction; it responds to all of the seq operations. A specific vector like <code>[:seltzer :water] </code>is an <em>instance</em> of that data type.</p>
      <p class="Body">The more a programming language lets you think and write in terms of abstractions, the more productive you will be. For example, if you learn that a data structure is an instance of the seq abstraction, you can instantly call forth a large web of knowledge about what functions will work with the data structure. As a result, you spend time actually using the data structure instead of constantly looking up documentation on how it works. By the same token, if you extend a data structure to work with the seq abstraction, you can use the extensive library of seq functions on it.</p>
      <p class="Body">In Chapter 4, you learned that Clojure is written in terms of abstractions. This is powerful because in Clojure you can focus on what you can actually do with data structures and not worry about the nitty-gritty of implementation. This chapter introduces you to the world of creating and implementing your own abstractions. You’ll learn the basics of multimethods, protocols, and records.</p>
      <h2>Polymorphism</h2>
      <p class="BodyFirst"><span>The main way we achieve abstraction in Clojure is by associating an </span>operation name with more than one algorithm. This technique is called <em>poly­morphism</em><span>. For example, the algorithm for performing </span><code>conj</code><span> on a list is </span><span>different from the one for vectors, but we unify them under the same name to indicate that they implement the same concept, namely, </span><em>add an element to </em><em>this data structure</em>.</p>
      <p class="Body">Because Clojure relies on Java’s standard library for many of its data types, a little Java is used in this chapter. For example, Clojure strings are just Java strings, instances of the Java class <code>java.lang.String</code>. To define your own data types in Java, you use classes. Clojure provides additional type constructs: <em>records</em> and<em> </em><em>types</em>. This book only covers records.</p>
      <p class="Body">Before we learn about records, though, let’s look at multimethods, our first tool for defining polymorphic behavior.</p>
      <h3>Multimethods</h3>
      <p class="BodyFirst"><em>Multimethods</em> give you a direct, flexible way to introduce polymorphism into your code. Using multimethods, you associate a name with multiple implementations by defining a <em>dispatching function</em>, which produces <em>dispatching values</em> that are used to determine which <em>method</em> to use. The dispatching function is like the host at a restaurant. The host will ask you questions like “Do you have a reservation?” and “Party size?” and then seat you accordingly. Similarly, when you call a multimethod, the dispatching function will interrogate the arguments and send them to the right method, as this example shows:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">were-creatures</span><span class="tok-p">)</span>
<span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">full-moon-behavior</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-ss">:were-type</span> <span class="tok-nv">were-creature</span><span class="tok-p">)))</span>
<span class="tok-err">➋</span> <span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">full-moon-behavior</span> <span class="tok-ss">:wolf</span>
  <span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">were-creature</span><span class="tok-p">)</span> <span class="tok-s">" will howl and murder"</span><span class="tok-p">))</span>
<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">full-moon-behavior</span> <span class="tok-ss">:simmons</span>
  <span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">were-creature</span><span class="tok-p">)</span> <span class="tok-s">" will encourage people and sweat to the oldies"</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">{</span><span class="tok-ss">:were-type</span> <span class="tok-ss">:wolf</span>
<span class="tok-err">➍</span>                      <span class="tok-ss">:name</span> <span class="tok-s">"Rachel from next door"</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; "Rachel from next door will howl and murder"</span>

<span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Andy the baker"</span>
<span class="tok-err">➎</span>                      <span class="tok-ss">:were-type</span> <span class="tok-ss">:simmons</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; "Andy the baker will encourage people and sweat to the oldies"</span>
</code></pre></div></div>

      <p class="Body">This multimethod shows how you might define the full moon behavior of different kinds of were-creatures. Everyone knows that a werewolf turns into a wolf and runs around howling and murdering people. A lesser-known <span>species of were-creature, the </span><span>were-Simmons</span><span>, turns into Richard Simmons, power perm and all, and runs around encouraging people to be their best and sweat to the oldies. You do not want to get bitten by either, lest </span><em>you</em><span> turn into one.</span></p>
      <img src="/assets/images/cftbat/multimethods-records-protocols/weresimmons.png" class="figure" />
      <p class="Body">We create the multimethod <span>at </span>➊<span>. This tells Clojure, “Hey, </span><span>create</span><span> a new multimethod named </span><code>full-moon-behavior</code><span>. Whenever </span>someone calls <code>full-moon-behavior</code>, <span>run the dispatching function </span><code>(fn [were-creature] (:were-type were-creature))</code> on the arguments. Use the result of that function, aka the dispatching value, to decide which specific method to use!” </p>
      <p class="Body">Next, we define two methods, one for when the value returned by the dispatching function is <code>:wolf</code> at ➋, and one for when it’s <code>:simmons</code> at ➌. Method definitions look a lot like function definitions, but the major difference is that the method name is immediately followed by the <em>dispatch value</em>. <code>:wolf</code> and <code>:simmons</code> are both <em>dispatch values</em>. This is different from a <span>dispatch</span><em>ing</em>  value, which is what the dispatching function returns. The full dispatch sequence goes like this:</p>
      <ol class="List-1">
	<li class="NumListA">The form <code>(full-moon-behavior {:were-type :wolf :name "Rachel from next door"})</code> is evaluated.</li>
	<li class="NumListB"><code>full-moon-behavior</code>’s dispatching function runs, returning <code>:wolf</code> as the dispatching value.</li>
	<li class="NumListB">Clojure compares the dispatching value <code>:wolf</code> to the dispatch values of all the methods defined for <code>full-moon-behavior</code>. The dispatch values are <code>:wolf</code> and <code>:simmons</code>.</li>
	<li class="NumListC">Because the dispatching value <code>:wolf</code> is equal to the dispatch value <code>:wolf</code>, the algorithm for <code>:wolf</code> runs.</li>
      </ol>
      <p class="Body">Don’t let the terminology trip you up! The main idea is that the dispatching function returns some value, and this value is used to determine which method definition to use.</p>
      <p class="Body">Back to our example! Next we call the method twice. At ➍, the dispatching function returns the value <code>:wolf</code> and the corresponding method is used, informing you that <code>"Rachel from next door will howl and murder"</code>. At ➏, the function behaves similarly, except <code>:simmons</code> is the dispatching value.</p>
      <p class="Body">You can define a method with <code>nil</code> as the dispatch value:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">full-moon-behavior</span> <span class="tok-nv">nil</span>
  <span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">were-creature</span><span class="tok-p">)</span> <span class="tok-s">" will stay at home and eat ice cream"</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">{</span><span class="tok-ss">:were-type</span> <span class="tok-nv">nil</span>
                     <span class="tok-ss">:name</span> <span class="tok-s">"Martin the nurse"</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; "Martin the nurse will stay at home and eat ice cream"</span>
</code></pre></div></div>

      <p class="Body">When you call <code>full-moon-behavior</code> this time, the argument you give it has <code>nil</code> for its <code>:were-type</code>, so the method corresponding to <code>nil</code> gets evaluated and you’re informed that <code>"Martin the nurse will stay at home and eat ice cream"</code>.</p>
      <p class="Body">You can also define a default method to use if no other methods match by specifying <code>:default</code> as the dispatch value. In this example, the <code>:were-type</code> <span>of the argument given doesn’t match any of the previously defined methods, </span>so the default method is used:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">full-moon-behavior</span> <span class="tok-ss">:default</span>
  <span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">were-creature</span><span class="tok-p">)</span> <span class="tok-s">" will stay up all night fantasy footballing"</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">{</span><span class="tok-ss">:were-type</span> <span class="tok-ss">:office-worker</span>
                     <span class="tok-ss">:name</span> <span class="tok-s">"Jimmy from sales"</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; "Jimmy from sales will stay up all night fantasy footballing"</span>
</code></pre></div></div>

      <p class="Body"><span>One cool thing about multimethods is that you can always add new methods. If you publish a library that includes the </span><code>were-creatures</code><span> namespace, other people can continue extending the multimethod to </span><span>handle</span> new dispatch values. This example shows that you’re creating your own random namespace and including the <code>were-creatures</code> namespace, and then defining another method for the <code>full-moon-behavior</code> multimethod:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">random-namespace</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">were-creatures</span><span class="tok-p">]))</span>
<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">were-creatures/full-moon-behavior</span> <span class="tok-ss">:bill-murray</span>
  <span class="tok-p">[</span><span class="tok-nv">were-creature</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">were-creature</span><span class="tok-p">)</span> <span class="tok-s">" will be the most likeable celebrity"</span><span class="tok-p">))</span>
<span class="tok-p">(</span><span class="tok-nf">were-creatures/full-moon-behavior</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Laura the intern"</span> 
                                    <span class="tok-ss">:were-type</span> <span class="tok-ss">:bill-murray</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; "Laura the intern will be the most likeable celebrity"</span>
</code></pre></div></div>

      <p class="Body">Your dispatching function can return arbitrary values using any or all of its arguments. The next example defines a multimethod that takes two arguments and returns a vector containing the type of each argument. It also defines an implementation of that method, which will be called when each argument is a string:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">user</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-kd">defmulti </span><span class="tok-nv">types</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">[(</span><span class="tok-nb">class </span><span class="tok-nv">x</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nb">class </span><span class="tok-nv">y</span><span class="tok-p">)]))</span>
<span class="tok-p">(</span><span class="tok-kd">defmethod </span><span class="tok-nv">types</span> <span class="tok-p">[</span><span class="tok-nv">java.lang.String</span> <span class="tok-nv">java.lang.String</span><span class="tok-p">]</span>
  <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span>
  <span class="tok-s">"Two strings!"</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">types</span> <span class="tok-s">"String 1"</span> <span class="tok-s">"String 2"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "Two strings!"</span>
</code></pre></div></div>

      <p class="Body">Incidentally, this is why they’re called <em>multi</em>methods: they allow dispatch on multiple arguments. I haven’t used this feature very often, but I could see it being used in a role-playing game to write methods that are dispatched according to, say, a mage’s major school of magic and his magic specialization. Either way, it’s better to have it and not need it than need it and not have it.</p>
      <p class="Note para-style-override-2"><span class="Note-Head">Note</span>	Multimethods also allow <span class="EmphasisNote">hierarchical dispatching</span>. Clojure lets you build custom hierarchies, which I won’t cover, but you can learn about them by reading the documentation at <span class="EmphasisNote"><a href="http://clojure.org/multimethods/">http://clojure.org/multimethods/</a></span>. </p>
      <h3>Protocols</h3>
      <p class="BodyFirst">Approximately 93.58 percent of the time, you’ll want to dispatch to methods according to an argument’s type. For example, <code>count</code> needs to use a different method for vectors than it does for maps or for lists. Although it’s possible to perform type dispatch with multimethods, <em>protocols</em> are optimized for type dispatch. They’re more efficient than multimethods, and Clojure makes it easy for you to succinctly specify protocol implementations.</p>
      <p class="Body">A multimethod is just one polymorphic operation, whereas a protocol is a <em>collection</em> of one or more polymorphic operations. Protocol operations are called methods, just like multimethod operations. Unlike multimethods, which perform dispatch on arbitrary values returned by a dispatching function, protocol methods are dispatched based on the type of the first argument, as shown in this example:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">data-psychology</span><span class="tok-p">)</span>
<span class="tok-err">➊</span><span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-err">➋</span><span class="tok-nv">Psychodynamics</span>
  <span class="tok-err">➌</span><span class="tok-s">"Plumb the inner depths of your data types"</span>
  <span class="tok-err">➍</span><span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"The data type's innermost thoughts"</span><span class="tok-p">)</span>
  <span class="tok-err">➎</span><span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-s">"Feelings about self or other"</span><span class="tok-p">))</span>
</code></pre></div></div>

      <p class="Body">First, there’s <code>defprotocol</code> at ➊. This takes a name, <code>Psychodynamics</code> ➋, and an optional docstring, <code>"Plumb the inner depths of your data types"</code> ➌. Next are the method signatures. A <em>method signature</em> consists of a name, an argument specification, and an optional docstring. The first method signature is named <code>thoughts</code> ➍ and can take only one argument. The second is named <code>feelings-about</code> ➎ and can take one or two arguments. Protocols do have one limitation: the methods can’t have rest arguments. So a line like the following isn’t allowed:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-o">&amp;</span> <span class="tok-nv">others</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">By defining a protocol, you’re defining an abstraction, but you haven’t yet defined how that abstraction is implemented. It’s like you’re reserving <span>names for behavior (in this example, you’re reserving </span><code>thoughts</code><span> and </span><code>feelings-about</code><span>), </span>but you haven’t defined what exactly the behavior should be. If you were <span>to evaluate </span><code>(thoughts "blorb")</code><span>, you would get an exception that reads, “No implementation of method: thoughts of protocol: data-psychology/Psychodynamics found for class: java.lang.String.” Protocols dispatch on the</span> first argument’s type, so when you call <code>(thoughts "blorb")</code>, Clojure tries to look up the implementation of the <code>thoughts</code> method for strings, and fails.</p>
      <p class="Body">You can fix this sorry state of affairs by <em>extending</em> the string data type to <em>implement</em> the <code>Psychodynamics</code> protocol:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">java.lang.String</span>
<span class="tok-err">➋</span>   <span class="tok-nv">Psychodynamics</span>
<span class="tok-err">➌</span>   <span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">x</span> <span class="tok-s">" thinks, 'Truly, the character defines the data type'"</span><span class="tok-p">)</span>
<span class="tok-err">➍</span>   <span class="tok-p">(</span><span class="tok-nf">feelings-about</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">x</span> <span class="tok-s">" is longing for a simpler way of life"</span><span class="tok-p">))</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">x</span> <span class="tok-s">" is envious of "</span> <span class="tok-nv">y</span> <span class="tok-s">"'s simpler way of life"</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-s">"blorb"</span><span class="tok-p">)</span>
<span class="tok-err">➎</span> <span class="tok-c1">; =&gt; "blorb thinks, 'Truly, the character defines the data type'"</span>

<span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-s">"schmorb"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "schmorb is longing for a simpler way of life"</span>

<span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-s">"schmorb"</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "schmorb is envious of 2's simpler way of life"</span>
</code></pre></div></div>

      <p class="Body"><code>extend-type</code> is followed by the name of the class or type you want to extend and the protocol you want it to support—in this case, you specify the class <code>java.lang.String</code> at ➊ and the protocol you want it to support, <code>Psychodynamics</code>, at ➋. After that, you provide an implementation for both the <code>thoughts</code> method at ➌ and the <code>feelings-about</code> method at ➍. If you’re extending a type to implement a protocol, you have to implement every method in the protocol or Clojure will throw an exception. In this case, you can’t implement just <code>thoughts</code> or just <code>feelings</code>; you have to implement both.</p>
      <p class="Body">Notice that these method implementations don’t begin with <code>defmethod</code> <span>like multimethods do. In fact, they look similar to function definitions, </span>except without <code>defn</code>. To define a method implementation, you write a form <span>that starts with the method’s name, like </span><code>thoughts</code><span>, then supply a vector of parameters and the method’s body. These methods also allow arity overloading, just like functions, and you define multiple-arity method implementations similarly to multiple-arity functions. You can see this in the </span><code>feelings-about</code> implementation at ➍.</p>
      <p class="Body">After you’ve extended the <code>java.lang.String</code> type to implement the <code>Psychodynamics</code> protocol, Clojure knows how to dispatch the call <code>(thoughts "blorb")</code>, and you get the string <code>"blorb thinks, 'Truly, the character defines the data type'"</code> at ➎.</p>
      <p class="Body"><span>What if you want to provide a default implementation, like you did with multimethods? To do that, you can extend </span><code>java.lang.Object</code><span>. This works because every type in Java (and hence, Clojure) is a descendant of </span><code>java.lang.Object</code><span>. If that doesn’t quite make sense (perhaps because you’re </span>not familiar with object-oriented programming), don’t worry about it—just know that it works. Here’s how you would use this technique to provide a default implementation for the <code>Psychodynamics</code> protocol:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">extend-type</span> <span class="tok-nv">java.lang.Object</span>
  <span class="tok-nv">Psychodynamics</span>
  <span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"Maybe the Internet is just a vector for toxoplasmosis"</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">feelings-about</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"meh"</span><span class="tok-p">)</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"meh about "</span> <span class="tok-nv">y</span><span class="tok-p">))))</span>
  
<span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "Maybe the Internet is just a vector for toxoplasmosis"</span>

<span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-mi">3</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "meh"</span>

<span class="tok-p">(</span><span class="tok-nf">feelings-about</span> <span class="tok-mi">3</span> <span class="tok-s">"blorb"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "meh about blorb"</span>
</code></pre></div></div>

      <p class="Body">Because we haven’t defined a <code>Psychodynamics</code> implementation for numbers, Clojure dispatches calls to <code>thoughts</code> and <code>feelings-about</code> to the implementation defined for <code>java.lang.Object</code>.</p>
      <p class="Body">Instead of making multiple calls to <code>extend-type</code> to extend multiple types, you can use <code>extend-protocol</code>, which lets you define protocol implementations for multiple types at once. Here’s how you’d define the preceding protocol implementations:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nf">extend-protocol</span> <span class="tok-nv">Psychodynamics</span>
  <span class="tok-nv">java.lang.String</span>
  <span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"Truly, the character defines the data type"</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">feelings-about</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"longing for a simpler way of life"</span><span class="tok-p">)</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"envious of "</span> <span class="tok-nv">y</span> <span class="tok-s">"'s simpler way of life"</span><span class="tok-p">)))</span>
  
  <span class="tok-nv">java.lang.Object</span>
  <span class="tok-p">(</span><span class="tok-nf">thoughts</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"Maybe the Internet is just a vector for toxoplasmosis"</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">feelings-about</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span><span class="tok-p">]</span> <span class="tok-s">"meh"</span><span class="tok-p">)</span>
    <span class="tok-p">([</span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">"meh about "</span> <span class="tok-nv">y</span><span class="tok-p">))))</span>
</code></pre></div></div>

      <p class="Body">You might find this technique more convenient than using <code>extend-type</code>. Then again, you might not. How does <code>extend-type</code> make you feel? How about <code>extend-protocol</code>? Come sit down on this couch and tell me all about it.</p>
      <p class="Body"><span>It’s important to note that a protocol’s methods “belong” to the namespace that they’re defined in. In these examples, the fully quali</span>fied names of the <code>Psychodynamics</code> methods are <code>data-psychology/thoughts</code> and <code>data-psychology/feelings-about</code>. If you have an object-oriented background, <span>this might seem weird because methods belong to data types in OOP. But don’t freak out! It’s just another way that Clojure gives primacy to </span>abstractions. One consequence of this fact is that, if you want two different protocols to include methods with the same name, you’ll need to put the protocols in different namespaces.</p>
      <h2>Records</h2>
      <p class="BodyFirst">Clojure allows you to create <em>records</em>, which are custom, maplike data types. They’re maplike in that they associate keys with values, you can look up their values the same way you can with maps, and they’re immutable like maps. They’re different in that you specify <em>fields</em> for records. Fields are slots for data; using them is like specifying which keys a data structure should have. Records are also different from maps in that you can extend them to implement protocols.</p>
      <p class="Body">To create a record, you use <code>defrecord</code> to specify its name and fields:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">were-records</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">WereWolf</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">title</span><span class="tok-p">])</span>
</code></pre></div></div>

      <p class="Body">This record’s name is <code>WereWolf</code>, and its two fields are <code>name</code> and <code>title</code>. You can create an instance of this record in three ways:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-nf">WereWolf.</span> <span class="tok-s">"David"</span> <span class="tok-s">"London Tourist"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #were_records.WereWolf{:name "David", :title "London Tourist"}</span>

<span class="tok-err">➋</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;WereWolf</span> <span class="tok-s">"Jacob"</span> <span class="tok-s">"Lead Shirt Discarder"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #were_records.WereWolf{:name "Jacob", :title "Lead Shirt Discarder"}</span>

<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-nf">map-&gt;WereWolf</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Lucian"</span> <span class="tok-ss">:title</span> <span class="tok-s">"CEO of Melodrama"</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; #were_records.WereWolf{:name "Lucian", :title "CEO of Melodrama"}</span>
</code></pre></div></div>

      <p class="Body">At ➊, we create an instance the same way we’d create a Java object, using the class instantiation interop call. (<em>Interop</em> refers to the ability to interact with native Java constructs within Clojure.) Notice that the arguments must follow the same order as the field definition. This works because records are actually Java classes under the covers. </p>
      <p class="Body">The instance at ➋ looks nearly identical to the one at ➊, but the key difference is that <code>-&gt;WereWolf</code> is a function. When you create a record, the factory functions <code>-&gt;</code><span class="LiteralItal">RecordName</span> and <code>map-&gt;</code><span class="LiteralItal">RecordName</span> are created automatically. At ➌, <code>map-&gt;WereWolf</code> takes a map as an argument with keywords that correspond to the record type’s fields and returns a record.</p>
      <p class="Body">If you want to use a record type in another namespace, you’ll have to import it, just like you did with the Java classes in Chapter 12. Be careful to replace all dashes in the namespace with underscores. This brief example shows how you’d import the <code>WereWolf</code> record type in another namespace:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">monster-mash</span>
  <span class="tok-p">(</span><span class="tok-ss">:import</span> <span class="tok-p">[</span><span class="tok-nv">were_records</span> <span class="tok-nv">WereWolf</span><span class="tok-p">]))</span>
<span class="tok-p">(</span><span class="tok-nf">WereWolf.</span> <span class="tok-s">"David"</span> <span class="tok-s">"London Tourist"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #were_records.WereWolf{:name "David", :title "London Tourist"}</span>
</code></pre></div></div>

      <p class="Body">Notice that <code>were_records</code> has an underscore, not a dash.</p>
      <p class="Body">You can look up record values in the same way you look up map values, and you can also use Java field access interop:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">jacob</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;WereWolf</span> <span class="tok-s">"Jacob"</span> <span class="tok-s">"Lead Shirt Discarder"</span><span class="tok-p">))</span>
<span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-nf">.name</span> <span class="tok-nv">jacob</span><span class="tok-p">)</span> 
<span class="tok-c1">; =&gt; "Jacob"</span>

<span class="tok-err">➋</span> <span class="tok-p">(</span><span class="tok-ss">:name</span> <span class="tok-nv">jacob</span><span class="tok-p">)</span> 
<span class="tok-c1">; =&gt; "Jacob"</span>

<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-nb">get </span><span class="tok-nv">jacob</span> <span class="tok-ss">:name</span><span class="tok-p">)</span> 
<span class="tok-c1">; =&gt; "Jacob"</span>
</code></pre></div></div>

      <p class="Body">The first example, <code>(.name jacob)</code> at ➊, uses Java interop, and the <span>examples</span> at ➋ and ➌ access <code>:name</code> the same way you would with a map.</p>
      <p class="Body">When testing for equality, Clojure will check that all fields are equal and that the two comparands have the same type:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">jacob</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;WereWolf</span> <span class="tok-s">"Jacob"</span> <span class="tok-s">"Lead Shirt Discarder"</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; true</span>

<span class="tok-err">➋</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">jacob</span> <span class="tok-p">(</span><span class="tok-nf">WereWolf.</span> <span class="tok-s">"David"</span> <span class="tok-s">"London Tourist"</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; false</span>

<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">jacob</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Jacob"</span> <span class="tok-ss">:title</span> <span class="tok-s">"Lead Shirt Discarder"</span><span class="tok-p">})</span>
<span class="tok-c1">; =&gt; false</span>
</code></pre></div></div>

      <p class="Body">The test at ➊ returns <code>true</code> because <code>jacob</code> and the newly created record are of the same type and their fields are equal. The test at ➋ returns <code>false</code> because the fields aren’t equal. The final test at ➌ returns <code>false</code> because the two comparands don’t have the same type: <code>jacob</code> is a <code>WereWolf</code> record, and the other argument is a map.</p>
      <p class="Body">Any function you can use on a map, you can also use on a record:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">assoc </span><span class="tok-nv">jacob</span> <span class="tok-ss">:title</span> <span class="tok-s">"Lead Third Wheel"</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; #were_records.WereWolf{:name "Jacob", :title "Lead Third Wheel"}</span>
</code></pre></div></div>

      <p class="Body">However, if you <code>dissoc</code> a field, the result’s type will be a plain ol’ Clojure map; it won’t have the same data type as the original record:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-p">(</span><span class="tok-nb">dissoc </span><span class="tok-nv">jacob</span> <span class="tok-ss">:title</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; {:name "Jacob"} &lt;- that's not a were_records.WereWolf</span>
</code></pre></div></div>

      <p class="Body">This matters for at least two reasons: first, accessing map values is slower than accessing record values, so watch out if you’re building a high-<span>performance program. Second, when you create a new record type, you </span>can extend it to implement a protocol, similar to how you extended a type using <code>extend-type</code><span> earlier. If you </span><code>dissoc</code><span> a record and then try to call a protocol method </span>on the result, the record’s protocol method won’t be called.</p>
      <p class="Body">Here’s how you would extend a protocol when defining a record:</p>
      <div class="listingblock"><div class="content"><pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">➊</span> <span class="tok-p">(</span><span class="tok-kd">defprotocol </span><span class="tok-nv">WereCreature</span>
<span class="tok-err">➋</span>   <span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]))</span>

<span class="tok-err">➌</span> <span class="tok-p">(</span><span class="tok-kd">defrecord </span><span class="tok-nv">WereWolf</span> <span class="tok-p">[</span><span class="tok-nb">name </span><span class="tok-nv">title</span><span class="tok-p">]</span>
  <span class="tok-nv">WereCreature</span>
  <span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
    <span class="tok-p">(</span><span class="tok-nb">str name </span><span class="tok-s">" will howl and murder"</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">full-moon-behavior</span> <span class="tok-p">(</span><span class="tok-nf">map-&gt;WereWolf</span> <span class="tok-p">{</span><span class="tok-ss">:name</span> <span class="tok-s">"Lucian"</span> <span class="tok-ss">:title</span> <span class="tok-s">"CEO of Melodrama"</span><span class="tok-p">}))</span>
<span class="tok-c1">; =&gt; "Lucian will howl and murder"</span>
</code></pre></div></div>

      <p class="Body"><span>We’ve created a new protocol, </span><code>WereCreature</code><span class="Default-Paragraph-Font"> </span>➊<span>, with one method, </span><code>full-moon-behavior</code><span class="Default-Paragraph-Font"> </span>➋. At ➌, <code>defrecord</code> implements <code>WereCreature</code> for <code>WereWolf</code>. The most interesting part of the <code>full-moon-behavior</code> implementation is that you have access to <code>name</code>. You also have access to <code>title</code> and any other fields that might be defined for your record. You can also extend records using <code>extend-type</code> and <code>extend-protocol</code>.</p>
      <p class="Body">When should you use records, and when should you use maps? In general, you should consider using records if you find yourself creating maps with the same fields over and over. This tells you that that set of data represents information in your application’s domain, and your code will communicate its purpose better if you provide a name based on the concept you’re trying to model. Not only that, but record access is more performant than map access, so your program will become a bit more efficient. Finally, if you want to use protocols, you’ll need to create a record.</p>
      <h2>Further Study</h2>
      <p class="BodyFirst">Clojure offers other tools for working with abstractions and data types. These tools, which I consider advanced, include <code>deftype</code>, <code>reify</code>, and <code>proxy</code>. If you’re interested in learning more, check out the documentation on data types at <em><a href="http://clojure.org/reference/datatypes/">http://clojure.org/datatypes/</a></em>.</p>
      <h2>Summary</h2>
      <p class="BodyFirst">One of Clojure’s design principles is to write to abstractions. In this chapter, you learned how to define your own abstractions using multimethods and prototypes. These constructs provide polymorphism, allowing the same operation to behave differently based on the arguments it’s given. You also learned how to create and use your own associative data types with <code>defrecord</code> and how to extend records to implement protocols.</p>
      <p class="Body">When I first started learning Clojure, I was pretty shy about using multi­methods, protocols, and records. However, they are used often in Clojure libraries, so it’s good to know how they work. Once you get the hang of them, they’ll help you write cleaner code.</p>
      <h2>Exercises</h2>
      <ol class="List-1">
	<li class="NumListA">Extend the <code>full-moon-behavior</code> multimethod to add behavior for your own kind of were-creature.</li>
	<li class="NumListB">Create a <code>WereSimmons</code> record type, and then extend the <code>WereCreature</code> protocol.</li>
	<li class="NumListB">Create your own protocol, and then extend it using <code>extend-type</code> and <code>extend-protocol</code>.</li>
	<li class="NumListC">Create a role-playing game that implements behavior using multiple dispatch.</li>
      </ol>
    
  

