<!DOCTYPE HTML>
<html lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta path="/quests/reducers/know-your-reducers/">
  
  <title>Know Your Reducers | Parallel Programming in Clojure with Reducers</title>
  
  <link rel="stylesheet" href="/assets/stylesheets/main.css">
  <link rel="stylesheet" href="/assets/stylesheets/pygments.css">
  <link href="//fonts.googleapis.com/css?family=Roboto+Condensed:400,700italic,700,400italic,300italic,300%7CSource+Sans+Pro:400,200,200italic,300,300italic,400italic,600italic,600,700,700italic,900italic,900%7CSource+Code+Pro:400,700%7CGentium+Book+Basic:400,400italic,700,700italic%7CCourgette" rel="stylesheet" type="text/css">
</head>

  <body class="reducers-book">
    <div class="nav">
  <div class="container">
    <div>
      <ul>
        <li><a href="/">Brave Clojure</a></li>
        <li><a href="https://jobs.braveclojure.com">Jobs</a></li>
        <li><a href="http://open-source.braveclojure.com">Open Source Projects</a></li>
        <li><a href="/quests/deploy">Deployment Book</a></li>
        <li><a href="/quests/reducers/intro">Reducers Book</a></li>
        <li><a href="/training">On-Site Training</a></li>
      </ul>
    </div>
  </div>
</div>

    <div class="header">
      <div class="logoy">
        <div class="container">
          <div class="subtitle">
            the palmco employee guide to
          </div>
          <div class="title">
            <a href="/quests/reducers/intro">
              <strong>Parallel Programming</strong> in <strong>Clojure</strong> with <strong>Reducers</strong>
            </a>
          </div>
        </div>
      </div>
    </div>
    <div class="callout">
      <div class="container">
        <form action="//flyingmachinestudios.us1.list-manage.com/subscribe/post?u=60763b0c4890c24bd055f32e6&amp;amp;id=0b40ffd1e1" class="validate" id="mc-embedded-subscribe-form" method="post" name="mc-embedded-subscribe-form" novalidate="" target="_blank">
          <p>
            Follow
            <a href="https://twitter.com/nonrecursive">@nonrecursive</a>
            to hear about new content
            or subscribe:
            <input class="email" id="mce-EMAIL" name="EMAIL" placeholder="email address" required="" type="email" value="">
            <input class="button" id="mc-embedded-subscribe" name="subscribe" type="submit" value="get updates!">
          </p>
        </form>
      </div>
    </div>
    <div class="buy">
      <div class="container">
      <div class="hero">
        <h1>Buy the (beta) ebook!?</h1>
        <div class="hype">
          <p>
            Hello, brave and true reader!
          </p>
          <p>
            Someone recently informed me that it's not completely
            crazypants to charge a sustainable amount for high quality
            programming content. This was news to me, but I
            thought, <em>hey, why not give it a shot?</em>
          </p>
          <h3>The First Part's Free</h3>
          <p>
            For this book on parallel programming, I'm releasing the
            <a href="/quests/reducers/intro">Introduction</a> and
            <a href="/quests/reducers/know-your-reducers">Part 1</a>
            for free (I guess I haven't really absorbed the
            lesson?). Part 1 is a practical tutorial that will teach
            you how to use reducers; I want every Clojurist to be able
            to use this useful tool. If you want Parts 2 and 3, you'll
            need to buy the (beta) ebook.
          </p>
          <h3>The ebook is where the awesome is</h3>
          <p>
            One of the reasons you love Clojure is that it makes
            advanced (but relevant) programming concepts and
            techniques accessible. It is <em>mentally stimulating</em>
            and <em>fun</em> and <em>actually useful</em>. In Parts 2 and
            3, you will explore exciting new programming
            vistas. Recall how you felt learning about Clojure's state
            model, or learning about programming with pure
            functions. You'll get that sense of <em>wow!</em>
            and <em>holy schnitzel, that's amazing!</em> in the paid
            parts of the book.
          </p>
          <p>
            Parallel programming has become more and more relevant
            because of the inexorable lurch toward multi-core
            processors. You'll learn about parallel programming
            concepts and techniques in Part 2, adding
            an <strong>invaluable tool</strong> to your mental
            toolkit. These ideas are universal; you can apply them
            outside Clojure.
          </p>
          <p>
            In Part 3 (unreleased; still in progress), you'll look at
            how the reducers library is implemented, and in the
            process explore some <strong>grade-A functional
            programming voodoo</strong>. You'll also see
            how <em>protocols</em> and <em>reification</em> in Clojure
            can be put to heart-breakingly elegant use. Once I release
            Part 3, I'll send you an email and you'll be able to
            download an update. I plan on finishing the book by
            October 2017. The book is currently about 68 pages, and I
            plan on adding 50-70 more.
          </p>
          <p>
            Writing this stuff is a ton of work, and if you like what
            you read, want to learn more, and want to help me finish
            this book, then please purchase an ebook. When Gumroad
            sends me the email notifying me of your purchase, I'll
            show my thanks by printing out your email address and
            drawing a heart around it. Thank you for your support!
          </p>
          <p>
            <em>— Daniel Higginbotham, programmer, author, and heart drawer</em>
          </p>
        </div>
        <div class="cover">
          <a href="https://gum.co/reducers">
            <img src="/quests/reducers/images/parallel-cover-1.png">
          </a>
        </div>
        <div class="buy">
          <a href="https://gum.co/reducers">buy the pdf, mobi, and epub for $28</a>
        </div>
      </div>
    </div>
    </div>
    <div class="container wrap">
      <div class="main">
        <div class="chapter-nav">



<div class="prev"><a href="../intro/">← Intro</a></div>



<div class="next"><a href="../appendix-a/">Appendix A: Other options →</a></div>


</div>

        <h1>Know Your Reducers</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In one episode of <em>Man vs. Wild</em> Will Ferrell, Hollywood actor and
comedian, accompanies Bear Grylls, professional survivalist, deep
inside the Arctic circle. The very first thing Grylls makes Ferrell do
is rappel from a helicopter hovering 150 feet above the ground. As
Ferrell makes his descent, he has only one word for the camera:
"<em>Mommy!</em>"</p>
</div>
<div class="paragraph">
<p>That’s about how I felt when I was first tried to learn about
reducers: plunked down far from home in a completely foreign and
uncomfortable landscape. Let’s avoid creating that feeling in you by
starting with something familiar: seq functions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Reducers_vs__Seq_Functions">Reducers vs. Seq Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The reducers library (in the <code>clojure.core.reducers</code> namespace) has
alternative implementations of <code>map</code>, <code>filter</code>, and other seq
functions. These alternative functions are called <em>reducers</em>, and you
can apply almost everything you know about seq functions to
reducers. Just like seq functions, the purpose of reducers is to
transform collections. For example, if you wanted to increment every
number in a vector, filter out the even ones, and sum the numbers, the
seq and reducer versions look virtually identical. Try this in a REPL:</p>
</div>
<div class="listingblock">
<div class="title">seq functions and reducers are identical in many ways</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;; seq version</span>
<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">even?</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">+</span><span class="tok-p">))</span>
<span class="tok-c1">;=&gt; 30</span>

<span class="tok-c1">;; reducer version</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">clojure.core.reducers</span> <span class="tok-ss">:as</span> <span class="tok-nv">r</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nv">+</span><span class="tok-p">))</span>
<span class="tok-c1">;=&gt; 30</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In both examples, <code>(range 10)</code> returns a seq of the numbers 0
through 9. In the first example, <code>map</code> is a seq function. In the
second, <code>r/map</code> is a reducer. In both examples, <code>map</code> has the same
purpose: transforming an input collection to an output by applying a
function to each element of the input. Reducers are just another means
of transforming collections, and for the most part they’re used just
like the seq functions you already know and love.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">One Difference between Reducers and Seq Functions</div>
<div class="paragraph">
<p>One way that reducers are <em>not</em> like seq functions is that you can’t
call many seq functions like first on their return values: something
like <code>(first (r/map inc [1 2]))</code> won’t work. You’ll learn why soon.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>So why bother with them? Reducers are designed to perform better
(often dramatically better) than seq functions under some
circumstances by <em>performing eager computation</em>, <em>eliminating
intermediate collections</em> and <em>allowing parallelism</em>.</p>
</div>
<div class="paragraph">
<p>In fact, as far as I can tell, parallelization is the main reason Rich
Hickey, Lambda Whisperer added reducers to the language. The goal of
executing collection transformations in parallel completely determined
how reducers are designed, and even explains why we use the term
<em>reducers</em>: reduce operations can be trivially parallellized (you’ll
learn how by the end), and every collection transformation can be
expressed in terms of reduce (there’s a
<a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">big juicy math paper on
that</a>).</p>
</div>
<div class="paragraph">
<p>Thus, the reducers library is built around using reduce to transform
collections, and it’s designed this way to make parallelization
possible. Both eager computation and the elimination of intermediate
collections are secondary - but useful - consequences of this
design. (By the way: "elimination of intermediate collections" is a
freaking mouthful, so I’m going to start using <em>EIC</em>).</p>
</div>
<div class="paragraph">
<p>Let’s look at these three strategies more closely. After that, I’ll
share rules for how to ensure that your code makes use of each of
them, without going into much detail about why they work as
they do. Last, I’ll also give some examples of reducers at work,
showing how their performance compares to alternatives.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="The_Strategies">The Strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Understanding the reduce library’s three performance strategies -
<em>eager computation</em>, <em>EIC</em>, and <em>parallelism</em> - will give you the
rationale behind reducers, and that will help you understand their
implementation later on. Plus, these ideas are pretty groovy in their
own right. I know you’re <em>eager</em> to learn about <em>eager computation</em>,
so let’s go!</p>
</div>
<div class="sect2">
<h3 id="Eager_Computation">Eager Computation</h3>
<div class="paragraph">
<p><em>Eager computation</em> stands in contrast to Clojure’s core sequence
functions, which produce and consume <em>lazy sequences</em>. You may
remember that lazy seqs don’t compute their members until you try to
access them. (For a refresher on lazy sequences, check out
<a href="http://www.braveclojure.com/core-functions-in-depth/#Lazy_Seqs">the
lazy seqs section in CFTBAT</a>.) This is often a good performance
strategy because it saves your program from doing unnecessary
computations, but in cases where you know you have to <em>realize</em>
(compute the elements of) the entire seq, laziness actually introduces
some unnecessary overhead. Reducers perform eager computation: they
always compute every member of a collection, and that can improve
performance slightly.</p>
</div>
<div class="paragraph">
<p>Because reducers are eager, you shouldn’t use them with infinite
sequences unless you want something useless to happen. The reducer
would try to realize the entire sequence, which isn’t possible, and
consume all available memory in the process.</p>
</div>
<div class="paragraph">
<p>This isn’t to say that reducers can’t work on lazy seqs. They totally
can! They just fail if the lazy seq is infinite.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">An Irrelevant Personal Anecdote</div>
<div class="paragraph">
<p>Story time! When my brother and I were teenagers, we honed our
technique in using <em>The Lazy</em>, which was like the opposite of The
Force from Star Wars. In the same way that The Force had a vaguely
Eastern grounding in chi or whatever, The Lazy had a vaguely Eastern
grounding in the tao or whatever: it was the art of doing by not
doing. For example, I was supposed to do my own laundry, but I found
that if I left it by the washing machine long enough then my mom would
get disgusted and just do it.</p>
</div>
<div class="paragraph">
<p>It didn’t always work. Once, I had been writing in bed. I don’t
remember what (probably terrible poetry or some other teenagery
dreck), but I had been balling up my paper and throwing it at my waste
basket, and missing. My brother came into my room and I innocently
asked him, "Hey, could you pick up that piece of paper?" and
he did. Then, "Could you put it in that trash can?" And he
<em>almost</em> did. He leaned over to drop it, then realized what he was
being Lazied and threw it at my face instead.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Eliminating_Intermediate_Collections">Eliminating Intermediate Collections</h3>
<div class="paragraph">
<p>Reducers <em>don’t produce intermediate collections</em>. An intermediate
collection is a collection produced by one sequence transforming
function and passed as an argument to another sequence transforming
function. Let’s look at a kind of stupid example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-s">"Shake"</span> <span class="tok-s">"Bake"</span><span class="tok-p">)</span>           <span class="tok-c1">; ➊</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">%</span> <span class="tok-s">" it off"</span><span class="tok-p">))</span>        <span class="tok-c1">; ➋</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">clojure.string/lower-case</span><span class="tok-p">)</span> <span class="tok-c1">; ➌</span>
     <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]))</span>                      <span class="tok-c1">; ➍</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This code just takes a list of words ➊ and performs two <code>map</code>
operations. First, it appends <code>" it off"</code> to each string ➋, then it
lower cases each ➌. Finally, it puts the result in a vector ➍.</p>
</div>
<div class="paragraph">
<p>Silly code that would never really exist. What we care about here is
that the <code>map</code> at ➋ constructs a new collection (a lazy seq, as it
happens), and so does the <code>map</code> at ➌. Each of these intermediate
collections takes resources to construct and traverse. How
inefficient! Haters are going to hate on this inefficiency, but
luckily you can shake it off with reducers. (Note to self: more Taylor
Swift references!)</p>
</div>
<div class="paragraph">
<p>Looking at this code you can deduce that it would be more efficient to
just combine the two string functions into one:</p>
</div>
<div class="listingblock">
<div class="title">fusing two elemental functions</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nb">list </span><span class="tok-s">"Shake"</span> <span class="tok-s">"Bake"</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-p">(</span><span class="tok-nb">comp </span><span class="tok-nv">clojure.string/lower-case</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-nv">%</span> <span class="tok-s">" it off"</span><span class="tok-p">)))</span>
     <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This eliminates one of your intermediate collections, and makes your
code faster. In parallel programming terminology, you’d say that you
<em>fused</em> two <em>elemental functions</em> into one. An <em>elemental function</em> is
just a normal function, like <code>lower-case</code>, but we give it the
qualifier <em>elemental</em> to communicate that we’re talking about it in
the context of collection transformation; it’s applied to each element
of the collection. <em>Fusion</em> is the composition of elemental functions
to avoid producing intermediate collections.</p>
</div>
<div class="paragraph">
<p>It would be cumbersome to have to rewrite your code to achieve this
kind of fusion, though. Ideally, you want your collection
transformations to compose into one fused function without any manual
intervention on your part. You want to be able to write idiomatic
Clojure code (like the following) and have it "just work":</p>
</div>
<div class="listingblock">
<div class="title">you dream of a paradise where this composes through fusion</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">1000</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And hey, guess what! Reducers just work! They’re actually designed to
compose into a single fused elemental function when you chain them
like in the example above, without any manual labor on your part. In
the above example, it’s as if you’re telling Clojure, "Take a seq of
the numbers 0 through 999. For every element of that function, apply a
function that does three things: filters the element if it’s even,
then increments the result (assuming the element wasn’t filtered), and
then places the result in a vector."</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Transducer Performance</div>
<div class="paragraph">
<p>Transducers also eliminate intermediate collections. In order to use
them, you have to write code that looks slightly different from
bread-and-butter seq functions or reducers, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">comp </span><span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">even?</span><span class="tok-p">)</span>
               <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">))</span>
      <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">1000000</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a few minutes, you’ll see some numbers that show just how much EIC
can improve performance. But first, let’s look at the final
performance strategy that reducers enable: parallelism.</p>
</div>
</div>
<div class="sect2">
<h3 id="Parallelism">Parallelism</h3>
<div class="paragraph">
<p>Parallelism is the simultaneous execution of <em>tasks</em> on two or more
processors.</p>
</div>
<div class="paragraph">
<p><em>Task</em> is a nebulous word, so let’s define it. I use <em>task</em> to refer
to function calls, but from the perspective of the processor instead
of the programmer; execution instead of semantics. That’s still
nebulous, so let’s look at a concrete example.</p>
</div>
<div class="paragraph">
<p>We might as well start working on iFacePalm. After all, that’s what
I’m paying you for, right? Here’s some Clojure code we could write
that would get us started:</p>
</div>
<div class="listingblock">
<div class="title">A bright beginning to a game-changing app</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">lifeline-and-years-lived</span>
  <span class="tok-s">"Given a human subject, return vector of lifeline ratio and years</span>
<span class="tok-s">  person lived"</span>
  <span class="tok-p">[{</span><span class="tok-ss">:keys</span> <span class="tok-p">[</span><span class="tok-nv">palm-stats</span> <span class="tok-nv">life-history</span><span class="tok-p">]</span> <span class="tok-ss">:as</span> <span class="tok-nv">subject</span><span class="tok-p">}]</span>
  <span class="tok-p">[(</span><span class="tok-ss">:lifeline-ratio</span> <span class="tok-nv">palm-stats</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-ss">:years-lived</span> <span class="tok-nv">life-history</span><span class="tok-p">)])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function extracts a person’s lifeline ratio (length of lifeline
compared to hand size) and age at death, and putting the two in a
vector. Here’s how you’d use it:</p>
</div>
<div class="listingblock">
<div class="title">A bright beginning to a game-changing app</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">lifeline-and-years-lived</span> <span class="tok-p">{</span><span class="tok-ss">:palm-stats</span>   <span class="tok-p">{</span><span class="tok-ss">:lifeline-ratio</span> <span class="tok-mf">0.5</span><span class="tok-p">}</span>
                           <span class="tok-ss">:life-history</span> <span class="tok-p">{</span><span class="tok-ss">:years-lived</span> <span class="tok-mi">75</span><span class="tok-p">}})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From the programmer’s perspective, we’d call this a function call. We
care about the return value and how to relate that to other functions
according to business needs. We care about the meaning of the function
call.</p>
</div>
<div class="paragraph">
<p>From the execution perspective, we’d call it a task. It’s just some
work that needs to get done, and we don’t care about its meaning or
how it relates to business needs.</p>
</div>
<div class="paragraph">
<p>So, if I said to you, "Let’s speed this program up by putting this
task on another thread," you’d know that I’m not talking about
changing the meaning of the program. I’m just talking about some work
that needs to get done, and how to shuffle the work around for better
performance.</p>
</div>
<div class="paragraph">
<p>Now let’s say we wrote something like this:</p>
</div>
<div class="listingblock">
<div class="title">Task is used at any level of granularity</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">lifeline-and-years-lived</span> <span class="tok-nv">subjects</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same way that this is one function call, <code>map</code>, which results
in many applications of <code>lifeline-and-years-lived</code>, it’s one task that
results in the execution of many sub-tasks. You can treat the larger
task as single, black box task, just as you can treat the function as
a black box.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Learn more about Concurrency and Parallelism</div>
<div class="paragraph">
<p>For a more detailed explanation of concurrency and parallelism (with a
focus on concurrency), check out the first two sections fo <em>Clojure
for the Brave and True</em>'s chapter
<a href="http://www.braveclojure.com/concurrency/"><em>The Sacred Art of Concurrent
and Parallel Programming</em></a>. The chapter uses the classic Lady Gaga
Telephone example to explain the concepts, and describes how they’re
implemented on the JVM.</p>
</div>
<div class="paragraph">
<p>Or just wait until you get to the next major part of this article,
which is all about parallelism.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>So, parallelism is all about executing tasks simultaneously on
multiple processors. Given the right conditions (explained in the next
section), reducers will transparently subdivide their <em>transform a
collection</em> task into subtasks of <em>transform this partitioned portion
of a collection</em>. These subtasks will execute in parallel, and the
results are recombined, also transparently. So, for example, if you
have this code:</p>
</div>
<div class="listingblock">
<div class="title">parallelism example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nb">+ </span><span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10000000</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then Clojure will divide your vector of ten million numbers into sub
vectors of 512 elements, run <code>(reduce + subvector)</code> on those
subvectors in parallel, and combine the results.</p>
</div>
<div class="paragraph">
<p>This divide/parallelize/re-combine process relies on the <em>fork/join
framework</em>. It’s too soon to cover that, but do not be sad, gentle
reader, for it is covered in Part Two.</p>
</div>
<div class="paragraph">
<p>Now that you know about the performance strategies employed by
reducers, let’s look at how to actually use them.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="How_to_Use_Reducers">How to Use Reducers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You’ve seen how, for the most part, you can use reducers just like seq
functions. For example, this produces the same result as the seq
counterpart:</p>
</div>
<div class="listingblock">
<div class="title">quick reducer example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">clojure.core.reducers</span> <span class="tok-ss">:as</span> <span class="tok-nv">r</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nv">+</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; 8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a couple rules to keep in mind, though. First, if you want
to make use of parallelism, you have to use the <code>r/fold</code> function with a
<em>foldable</em> collection. <code>r/fold</code> is a parrallel implementation of <code>reduce</code>.</p>
</div>
<div class="paragraph">
<p>I need to explain parallelism a bit more before explaining what
<em>foldable</em> means, but for now the relevant fact is that vectors and
maps are the only foldable collections. So if you wrote code like
this, you might expect it to run in parallel, but it wouldn’t:</p>
</div>
<div class="listingblock">
<div class="title">only foldable collections can be parallelized</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">'</span><span class="tok-p">[</span><span class="tok-nv">clojure.core.reducers</span> <span class="tok-ss">:as</span> <span class="tok-nv">r</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-o">'</span><span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nv">+</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; [3 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Lists aren’t foldable, so reducers can’t operate on them in
parallel. Instead, the code falls back to serial <code>reduce</code>.</p>
</div>
<div class="paragraph">
<p>The second rule is that reducers <em>don’t produce collections</em>. It’s
awesome that <code>r/map</code> and <code>r/filter</code> compose without creating
intermediate collections, but the catch is that they behave a little
differently from seq functions. Here’s one way you could get tripped
up:</p>
</div>
<div class="listingblock">
<div class="title">sad broken bode</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">first </span><span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">; =&gt; java.lang.IllegalArgumentException: Don't know how to create ISeq from: clojure.core.reducers$folder$reify__17186</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This happens because <code>r/map</code> and the other reducers don’t actually
return a new collection. Instead, they return a <em>reducible</em>.</p>
</div>
<div class="paragraph">
<p>A reducible is like a recipe for how to produce a new collection,
along with a reference to a source collection. In the above example,
the recipe is "produce a new collection by incrementing each element
each element of the source collection", and the source collection is
the vector <code>[1 2 3]</code>.</p>
</div>
<div class="paragraph">
<p>Another way to put it: a reducible is an elemental function, along
with the collection whose elements you want to apply the function to.</p>
</div>
<div class="paragraph">
<p>And yet another way to put it: It’s as if you were one of Santa’s
worker elves (or some other mythical creature of labor), and the
foreman handed you a piece of paper with your instructions for the
day: "Go to the plastic shed out back, get all the plastic lumps and
turn them into toy whatevers to feed to the insatiable, gaping maw of
consumerism."</p>
</div>
<div class="paragraph">
<p>If I then walked up to you and said, "give me the first of that piece
of paper", you would look at me in confusion, because the request
wouldn’t make any sense. The piece of paper is not a collection that
you can take the first of. Similarly, when you tell Clojure <code>(first
(r/map inc [1 2 3]))</code> it expresses its confusion with an exception
because the request doesn’t make sense.</p>
</div>
<div class="paragraph">
<p>You might initially think you’re telling Clojure "give me the first
element of the <em>collection</em> returned by `r/map`", but you’re actually
saying "give me the first element of the <em>reducible</em> returned by
`r/map`". A reducible is a recipe for how to transform a given
collection, but it’s not a collection itself, so Clojure can’t fulfill
your request.</p>
</div>
<div class="paragraph">
<p>This design decision to have functions like <code>r/map</code> return a reducible
instead of a collection is what allows reducers to seamlessly compose,
building up a single fused elemental function. I’ll explain exactly
how this happens later in the book, and for now rely on the power
of metaphor so that you’ll have a strong intuitive understanding of
how it works.</p>
</div>
<div class="paragraph">
<p>But you need to get collections <em>somehow</em>. If you want to use reducer
functions to produce another collection, you have to explicitly
realize the result collection by calling <code>r/foldcat</code> or
<code>clojure.core/into</code>. <code>r/foldcat</code> calls <code>r/fold</code> internally, and <code>into</code>
calls <code>reduce</code>. Here are two examples:</p>
</div>
<div class="listingblock">
<div class="title">successful reducer collection realization</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[])</span>
     <span class="tok-p">(</span><span class="tok-nf">first</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; 2</span>

<span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">]</span>
     <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">r/foldcat</span><span class="tok-p">)</span>
     <span class="tok-p">(</span><span class="tok-nf">first</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You should use <code>into</code> when you want to explicitly specify the
collection type. In the example above, you’re realizing the collection
as a vector. <code>into</code> is serial.</p>
</div>
<div class="paragraph">
<p><code>r/foldcat</code> executes parallelly (is that a word?) and returns a
collection that acts pretty much like a vector. The collection is
foldable, so you can use it with reducers in further parallel
computations. It’s also seqable, like a vector, so you can call
functions like <code>first</code> on it.</p>
</div>
<div class="paragraph">
<p>To summarize the rules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you want to parallelize your reduction, use <code>r/fold</code> and a
foldable collection (a vector or map).</p>
</li>
<li>
<p>If you want your transformations to return a collection, use <code>into</code>
or <code>r/foldcat</code>. <code>into</code> executes serially and lets you specify the
collection type, while <code>r/foldcat</code> is parallel and returns a
vector-like collection.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Soooo now that you’ve spent all this time learning about reducers'
performance strategies and how to use them, let’s wrap everything
together by comparing reducer performance to seq functions. If I’ve
done my job right, you won’t be surprised by the differences. If I
haven’t done my job right, then, well…​ sorry?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="A_Peek_at_Performance">A Peek at Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reducer performance depends on two variables:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Whether you’re producing intermediate collections</p>
</li>
<li>
<p>Whether you’re using <code>r/fold</code> with foldable collections</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To see the performance impact of these variables, we’re going to look
at similar computations performed using <code>r/fold</code> (for parallelism and
EIC), <code>r/reduce</code> (for EIC alone), and <code>clojure.core/reduce</code> as a
baseline. We’ll also perform the computations on foldable
collections (vectors) and on unfoldable collections (lazy seqs).</p>
</div>
<div class="paragraph">
<p>You can find the code for this section in the <em>code</em> folder of your
download under <em>src/ifacepalm/using_reducers.clj</em> (paid version
only). After doing the performance measurements for awhile, I wanted
to make the process a bit less tedious, so I wrote the macro <code>times</code>
and its helper functions <code>pretty-time</code> and <code>runs-and-pauses</code> to
abstract the process of running a snippet multiple times, timing each
run, averaging those time values, and usefully printing the
result. This lets you do something like this:</p>
</div>
<div class="listingblock">
<div class="title">times macro example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">let </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-p">(</span><span class="tok-nb">doall </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">1000000</span><span class="tok-p">)))]</span>
  <span class="tok-p">(</span><span class="tok-nf">times</span> <span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nb">+ </span><span class="tok-nv">x</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nb">+ </span><span class="tok-nv">x</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-nv">x</span><span class="tok-p">)))</span>
<span class="tok-s">"    6.62ms (r/fold + x)"</span>
<span class="tok-s">"   20.94ms (r/reduce + x)"</span>
<span class="tok-s">"   16.05ms (reduce + x)"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, you’re performing the same computation using three
different methods, and seeing how long each method takes.</p>
</div>
<div class="paragraph">
<p>The code for <code>times</code> is in the <code>ifacepalm.time-helpers</code> namespace, but
I’m not going to go over it here for fear that you would (justifiably)
shake your fist at me from behind your monitor for veering off topic.</p>
</div>
<div class="paragraph">
<p>Here are our first comparisons:</p>
</div>
<div class="listingblock">
<div class="title">Comparing performance for computationally simple ops</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-c1">;;------- Simple operations</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">snums</span>  <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">10000000</span><span class="tok-p">))</span> <span class="tok-c1">;</span>
<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">snumsv</span> <span class="tok-p">(</span><span class="tok-nf">vec</span> <span class="tok-nv">snums</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">t1</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">times</span> <span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nb">+ </span><span class="tok-nv">x</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nb">+ </span><span class="tok-nv">x</span><span class="tok-p">)</span>
         <span class="tok-p">(</span><span class="tok-nb">reduce + </span><span class="tok-nv">x</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">t2</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">times</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nv">+</span><span class="tok-p">))</span>
         <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nv">+</span><span class="tok-p">))</span>
         <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span>   <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">+</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">t3</span> <span class="tok-p">[</span><span class="tok-nv">x</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">times</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/fold</span> <span class="tok-nv">+</span><span class="tok-p">))</span>
         <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">r/filter</span> <span class="tok-nv">even?</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/map</span> <span class="tok-nv">inc</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">r/reduce</span> <span class="tok-nv">+</span><span class="tok-p">))</span>
         <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nb">filter </span><span class="tok-nv">even?</span><span class="tok-p">)</span>   <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">)</span>   <span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-nv">+</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>First, we define two collections of numbers from 0 to
99,999,999. <code>snums</code> is an unfoldable seq and <code>snumsv</code> is a foldable
vector.</p>
</div>
<div class="paragraph">
<p>Next, we define three functions, <code>t1</code>, <code>t2</code>, and <code>t3</code>. Each function
takes a collection (we’ll use <code>snums</code> and <code>snumsv</code>), transforms it
using <code>r/fold</code>, <code>r/reduce</code>, and <code>reduce</code>, and prints out how much time
each transformation takes. Enough with the yik yak, let’s actually use
them:</p>
</div>
<div class="listingblock">
<div class="title">Listing 1: Timing a simple reduce</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t1</span> <span class="tok-nv">snums</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "  127.28ms (r/fold + x)"</span>
<span class="tok-c1">; =&gt; "  131.67ms (r/reduce + x)"</span>
<span class="tok-c1">; =&gt; "  119.67ms (reduce + x)"</span>

<span class="tok-p">(</span><span class="tok-nf">t1</span> <span class="tok-nv">snumsv</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "   59.15ms (r/fold + x)"</span>
<span class="tok-c1">; =&gt; "  164.32ms (r/reduce + x)"</span>
<span class="tok-c1">; =&gt; "  148.15ms (reduce + x)"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When we call <code>t1</code> with <code>snums</code>, the three reduction functions have
roughly the same performance. Put another way: we don’t get any
performance benefits from EIC or parallelism. This makes sense because
we’re not doing a map, filter, or some other function that
semantically returns a new collection. We’re also using the unfoldable
<code>snums</code>, and in that case <code>r/fold</code> quietly degrades to <code>r/reduce</code>.</p>
</div>
<div class="paragraph">
<p>When we call <code>t2</code> with <code>snumsv</code>, though, we see a significant speedup
from <code>r/fold</code>. My computer has four cores, so ideally <code>r/fold</code> would
take 25% as much time as the serial versions, but it’s rare to meet
that ideal because parallelization has overhead costs.</p>
</div>
<div class="paragraph">
<p>Let’s see what happens when we have an intermediate transformation (map):</p>
</div>
<div class="listingblock">
<div class="title">reduce with an intermediate transformation</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t2</span> <span class="tok-nv">snums</span><span class="tok-p">)</span>
<span class="tok-c1">; =&gt; "  166.43ms (-&gt;&gt; x (r/map inc) (r/fold +))"</span>
<span class="tok-c1">; =&gt; "  169.32ms (-&gt;&gt; x (r/map inc) (r/reduce +))"</span>
<span class="tok-c1">; =&gt; "  322.66ms (-&gt;&gt; x (map inc) (reduce +))"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dayumn! The reducer versions take nearly fifty percent less time!
There’s no difference between <code>r/fold</code> and <code>r/reduce</code>, though, becuase
we’re not using a foldable collection. Here’s what happens when you
change that:</p>
</div>
<div class="listingblock">
<div class="title">reduce with an intermediate collection and foldable source</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t2</span> <span class="tok-nv">snumsv</span><span class="tok-p">)</span>
<span class="tok-s">"   74.45ms (-&gt;&gt; x (r/map inc) (r/fold +))"</span>
<span class="tok-s">"  214.04ms (-&gt;&gt; x (r/map inc) (r/reduce +))"</span>
<span class="tok-s">"  374.91ms (-&gt;&gt; x (map inc) (reduce +))"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>r/fold</code> is <em>five times faster</em> than <code>reduce</code>, thanks to EIC and
parallelism. (Interestingly, it seems serial reduce takes a bit longer
with vectors.)</p>
</div>
<div class="paragraph">
<p>What happens if you have two intermediate collections? This happens:</p>
</div>
<div class="listingblock">
<div class="title">reduce with two intermediate collections</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">t3</span> <span class="tok-nv">snums</span><span class="tok-p">)</span>
<span class="tok-s">"  184.07ms (-&gt;&gt; x (r/map inc) (r/filter even?) (r/fold +))"</span>
<span class="tok-s">"  181.03ms (-&gt;&gt; x (r/map inc) (r/filter even?) (r/reduce +))"</span>
<span class="tok-s">"  431.53ms (-&gt;&gt; x (map inc) (filter even?) (reduce +))"</span>

<span class="tok-p">(</span><span class="tok-nf">t3</span> <span class="tok-nv">snumsv</span><span class="tok-p">)</span>
<span class="tok-s">"   71.96ms (-&gt;&gt; x (r/map inc) (r/filter even?) (r/fold +))"</span>
<span class="tok-s">"  207.47ms (-&gt;&gt; x (r/map inc) (r/filter even?) (r/reduce +))"</span>
<span class="tok-s">"  478.25ms (-&gt;&gt; x (map inc) (filter even?) (reduce +))"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When you call <code>r/fold</code> with a vector, it’s almost seven times
faster. Not only that, but look at the times for the <code>r/reduce</code> calls
in <code>(t2 snumsv)</code> and <code>(t3 snumsv)</code>: 214ms and 207ms
respectively. Adding the intermediate transformation had virtually no
impact on performance. (It actually took less time in this case, but I
chalk that up to random noise.) Compare that to the <code>reduce</code> calls:
374ms and 478ms. Huge performance impact!</p>
</div>
<div class="paragraph">
<p>This should give you a good idea of the kinds of performance gains
that reducers can give you. And the best part is that your code will
perform even better if you run it on a machine with more cores,
without any extra work. Neat!</p>
</div>
<div class="paragraph">
<p>And thus concludes the introductory tutorial on reducers. Hopefully
I’ve given you everything you need to start using them
effectively. Next comes the <em>really</em> fun part: learning about
parallelism concepts so that you’ll have a complete understanding of
what the reducers library is doing.</p>
</div>
</div>
</div>
        <div class="chapter-nav">



<div class="prev"><a href="../intro/">← Intro</a></div>



<div class="next"><a href="../appendix-a/">Appendix A: Other options →</a></div>


</div>

        <div id="disqus_thread"></div>
<script>

  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://clojureforthebraveandtrue.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

      </div>
      <div class="secondary">
        <div class="wrapper">
          <div class="junk">
            <script src="https://gumroad.com/js/gumroad.js"></script>
            <a href="https://gum.co/reducers">
              <img src="/quests/reducers/images/parallel-cover-1.png">
              Read the full book!
            </a>
          </div>
          <div class="ads">
            <a class="twitter-follow-button" href="https://twitter.com/nonrecursive">Follow @nonrecursive</a>
            <form action="//flyingmachinestudios.us1.list-manage.com/subscribe/post?u=60763b0c4890c24bd055f32e6&amp;amp;amp;id=0b40ffd1e1" class="validate" id="mc-embedded-subscribe-form" method="post" name="mc-embedded-subscribe-form" novalidate="" target="_blank">
              <input class="email" id="mce-EMAIL" name="EMAIL" placeholder="email address" required="" type="email" value="">
              <input class="button" id="mc-embedded-subscribe" name="subscribe" type="submit" value="get email updates">
            </form>
            <ol>
              <li><a target="_blank" href="https://jobs.braveclojure.com">Find Clojure jobs</a></li>
            </ol>
          </div>
<div class="chapter-sections">Chapter Sections</div>
<ol class="toc">
<li><a href="/quests/reducers/know-your-reducers/#Reducers_vs__Seq_Functions">Reducers vs. Seq Functions</a></li>
<li>
<a href="/quests/reducers/know-your-reducers/#The_Strategies">The Strategies</a><ol>
<li><a href="/quests/reducers/know-your-reducers/#Eager_Computation">Eager Computation</a></li>
<li><a href="/quests/reducers/know-your-reducers/#Eliminating_Intermediate_Collections">Eliminating Intermediate Collections</a></li>
<li><a href="/quests/reducers/know-your-reducers/#Parallelism">Parallelism</a></li>
</ol>
</li>
<li><a href="/quests/reducers/know-your-reducers/#How_to_Use_Reducers">How to Use Reducers</a></li>
<li><a href="/quests/reducers/know-your-reducers/#A_Peek_at_Performance">A Peek at Performance</a></li>
</ol>
          <div class="chapters">
            <div class="subtitle">Chapters</div>
            <ol class="toc">
              <li>
                <a href="/quests/reducers/intro/">
                  Intro
                </a>
              </li>
              <li>
                <a href="/quests/reducers/know-your-reducers/">
                  Chapter 1: Know Your Reducers
                </a>
              </li>
              <li>
                Chapter 2: Performance and Parallelism (ebook-only)
              </li>
              <li>
                Chapter 3: Fork/Join and Implementation (in progess; ebook-only)
              </li>
            </ol>
          </div>
        </div>
      </div>
    </div>
    <div class="footer">
      <div class="container">
        <div>
          © 2017 Daniel Higginbotham
        </div>
      </div>
    </div>
    <script id="dsq-count-scr" src="//clojureforthebraveandtrue.disqus.com/count.js" async></script>
    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="/assets/scripts/jquery.sticky.js"></script>
    <script src="/assets/scripts/sticky.js"></script>
    <script>
              !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs')
            </script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-43463851-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
